<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LSD: lsd.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lsd.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LSD module code. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>rafael grompone von gioi (<a href="mailto:grompone@gmail.com">grompone@gmail.com</a>)</dd></dl>

<p>
Definition in file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;float.h&gt;</code><br>
<code>#include "<a class="el" href="lsd_8h-source.html">lsd.h</a>"</code><br>

<p>
Include dependency graph for lsd.c:<p><center><img src="lsd_8c__incl.png" border="0" usemap="#lsd.c_map" alt="Include dependency graph"></center>
<map name="lsd.c_map">
<area href="lsd_8h.html" shape="rect" coords="440,7,490,34" alt="">
</map>

<p>
<a href="lsd_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structcoorlist.html">coorlist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chained list of coordinates. </em> <a href="structcoorlist.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__char__s.html">image_char_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">char image data type </em> <a href="structimage__char__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__double__s.html">image_double_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double image data type </em> <a href="structimage__double__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structimage__int__s.html">image_int_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int image data type </em> <a href="structimage__int__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structntuple__list__s.html">ntuple_list_s</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'list of n-tuple' data type </em> <a href="structntuple__list__s.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structpoint.html">point</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A point (or pixel). </em> <a href="structpoint.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect.html">rect</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle structure: line segment with width. </em> <a href="structrect.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structrect__iter.html">rect_iter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rectangle points iterator. </em> <a href="structrect__iter.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a0">M_LN10</a>&nbsp;&nbsp;&nbsp;2.30258509299404568402</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ln(10) </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a1">M_PI</a>&nbsp;&nbsp;&nbsp;3.14159265358979323846</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PI. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a2">FALSE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a3">TRUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a4">NOTDEF</a>&nbsp;&nbsp;&nbsp;-1024.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels with undefined gradient. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a5">M_3_2_PI</a>&nbsp;&nbsp;&nbsp;4.71238898038</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3/2 pi </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a6">M_2__PI</a>&nbsp;&nbsp;&nbsp;6.28318530718</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2 pi </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a7">NOTUSED</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels not used in yet. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a8">USED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Label for pixels already used in detection. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a>&nbsp;&nbsp;&nbsp;100.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Doubles relative error factor. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a10">log_gamma</a>(x)&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a11">TABSIZE</a>&nbsp;&nbsp;&nbsp;100000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the table to store already computed inverse values. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structntuple__list__s.html">ntuple_list_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a12">ntuple_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">'list of n-tuple' data type </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__char__s.html">image_char_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a13">image_char</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">char image data type </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__int__s.html">image_int_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a14">image_int</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int image data type </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structimage__double__s.html">image_double_s</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a15">image_double</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double image data type </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a16">error</a> (char *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fatal error, print a message to standard-error output and exit. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a17">double_equal</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare doubles by relative error. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a18">dist</a> (double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes Euclidean distance between point (x1,y1) and point (x2,y2). </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a19">free_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in n-tuple 'in'. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a20">new_ntuple_list</a> (unsigned int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an n-tuple list and allocate memory for one element. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a21">enlarge_ntuple_list</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> n_tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enlarge the allocated memory of an n-tuple list. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a22">add_7tuple</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> out, double v1, double v2, double v3, double v4, double v5, double v6, double v7)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a 7-tuple to an n-tuple list. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a23">free_image_char</a> (<a class="el" href="structimage__char__s.html">image_char</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_char 'i'. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a24">new_image_char</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize'. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a25">new_image_char_ini</a> (unsigned int xsize, unsigned int ysize, unsigned char fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a26">new_image_int</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize'. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__int__s.html">image_int</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a27">new_image_int_ini</a> (unsigned int xsize, unsigned int ysize, int fill_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a28">free_image_double</a> (<a class="el" href="structimage__double__s.html">image_double</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used in image_double 'i'. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a29">new_image_double</a> (unsigned int xsize, unsigned int ysize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize'. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a30">new_image_double_ptr</a> (unsigned int xsize, unsigned int ysize, double *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new image_double of size 'xsize' times 'ysize' with the data pointed by 'data'. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a31">gaussian_kernel</a> (<a class="el" href="structntuple__list__s.html">ntuple_list</a> kernel, double sigma, double mean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a32">gaussian_sampler</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double scale, double sigma_scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a33">ll_angle</a> (<a class="el" href="structimage__double__s.html">image_double</a> in, double threshold, struct <a class="el" href="structcoorlist.html">coorlist</a> **list_p, void **mem_p, <a class="el" href="structimage__double__s.html">image_double</a> *modgrad, unsigned int n_bins)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the direction of the level line of 'in' at each point. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a34">isaligned</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, double theta, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is point (x,y) aligned to angle theta, up to precision 'prec'? </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a35">angle_diff</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value angle difference. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a36">angle_diff_signed</a> (double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signed angle difference. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a37">log_gamma_lanczos</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a38">log_gamma_windschitl</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a39">nfa</a> (int n, int k, double p, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes -log10(NFA). </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a40">rect_copy</a> (struct <a class="el" href="structrect.html">rect</a> *in, struct <a class="el" href="structrect.html">rect</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy one rectangle structure to another. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a41">inter_low</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a42">inter_hi</a> (double x, double x1, double y1, double x2, double y2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a43">ri_del</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used by a rectangle iterator. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a44">ri_end</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the iterator finished the full iteration. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a45">ri_inc</a> (<a class="el" href="structrect__iter.html">rect_iter</a> *i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment a rectangle iterator. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a46">ri_ini</a> (struct <a class="el" href="structrect.html">rect</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize a rectangle iterator. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a47">rect_nfa</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a rectangle's NFA value. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a48">get_theta</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, double x, double y, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute region's angle as the principal inertia axis of the region. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a49">region2rect</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a rectangle that covers a region of points. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a50">region_grow</a> (int x, int y, <a class="el" href="structimage__double__s.html">image_double</a> angles, struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, double *reg_angle, <a class="el" href="structimage__char__s.html">image_char</a> used, double prec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a51">rect_improve</a> (struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__double__s.html">image_double</a> angles, double logNT, double log_eps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try some rectangles variations to improve NFA value. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a52">reduce_region_radius</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a53">refine</a> (struct <a class="el" href="structpoint.html">point</a> *reg, int *reg_size, <a class="el" href="structimage__double__s.html">image_double</a> modgrad, double reg_angle, double prec, double p, struct <a class="el" href="structrect.html">rect</a> *rec, <a class="el" href="structimage__char__s.html">image_char</a> used, <a class="el" href="structimage__double__s.html">image_double</a> angles, double density_th)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine a rectangle. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a54">LineSegmentDetection</a> (int *n_out, double *img, int X, int Y, double scale, double sigma_scale, double quant, double ang_th, double log_eps, double density_th, int n_bins, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Full Interface. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a55">lsd_scale_region</a> (int *n_out, double *img, int X, int Y, double scale, int **reg_img, int *reg_x, int *reg_y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale and Region output. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a56">lsd_scale</a> (int *n_out, double *img, int X, int Y, double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface with Scale. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="lsd_8c.html#a57">lsd</a> (int *n_out, double *img, int X, int Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LSD Simple Interface. </em> <a href="#a57"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2" doxytag="lsd.c::FALSE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FALSE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00095">95</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="lsd.c::log_gamma" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define log_gamma</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((x)&gt;15.0?log_gamma_windschitl(x):log_gamma_lanczos(x))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x. 
<p>
When x&gt;15 use <a class="el" href="lsd_8c.html#a38">log_gamma_windschitl()</a>, otherwise use <a class="el" href="lsd_8c.html#a37">log_gamma_lanczos()</a>. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01005">1005</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="lsd.c::M_2__PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_2__PI&nbsp;&nbsp;&nbsp;6.28318530718
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00109">109</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00911">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00923">angle_diff_signed()</a>, and <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="lsd.c::M_3_2_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_3_2_PI&nbsp;&nbsp;&nbsp;4.71238898038
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
3/2 pi 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00106">106</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="lsd.c::M_LN10" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_LN10&nbsp;&nbsp;&nbsp;2.30258509299404568402
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ln(10) 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00086">86</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="lsd.c::M_PI" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define M_PI&nbsp;&nbsp;&nbsp;3.14159265358979323846
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
PI. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00091">91</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00911">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00923">angle_diff_signed()</a>, <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01736">rect_improve()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="lsd.c::NOTDEF" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTDEF&nbsp;&nbsp;&nbsp;-1024.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels with undefined gradient. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00103">103</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l00732">ll_angle()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="lsd.c::NOTUSED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NOTUSED&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels not used in yet. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00112">112</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="lsd.c::RELATIVE_ERROR_FACTOR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RELATIVE_ERROR_FACTOR&nbsp;&nbsp;&nbsp;100.0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Doubles relative error factor. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00148">148</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="lsd.c::TABSIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TABSIZE&nbsp;&nbsp;&nbsp;100000
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Size of the table to store already computed inverse values. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01010">1010</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="lsd.c::TRUE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TRUE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00099">99</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="lsd.c::USED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define USED&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Label for pixels already used in detection. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00115">115</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a13" doxytag="lsd.c::image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__char__s.html">image_char_s</a> *  <a class="el" href="structimage__char__s.html">image_char</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
char image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00332">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00343">new_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00368">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01927">refine()</a>, and <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="lsd.c::image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__double__s.html">image_double_s</a> *  <a class="el" href="structimage__double__s.html">image_double</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
double image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00458">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00732">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00469">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00493">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l01736">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01927">refine()</a>, <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>, and <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="lsd.c::image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structimage__int__s.html">image_int_s</a> *  <a class="el" href="structimage__int__s.html">image_int</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
int image data type 
<p>
The pixel value at (x,y) is accessed by:<p>
image-&gt;data[ x + y * image-&gt;xsize ]<p>
with x and y integer. 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00403">new_image_int()</a>, and <a class="el" href="lsd_8c-source.html#l00427">new_image_int_ini()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="lsd.c::ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="structntuple__list__s.html">ntuple_list_s</a> *  <a class="el" href="structntuple__list__s.html">ntuple_list</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
'list of n-tuple' data type 
<p>
The i component, of the n-tuple number j, of an n-tuple list 'ntl' is accessed with:<p>
ntl-&gt;values[ i + j * ntl-&gt;dim ]<p>
The dimension of the n-tuple (n) is:<p>
ntl-&gt;dim<p>
The number of n-tuples in the list is:<p>
ntl-&gt;size<p>
The maximum number of n-tuples that can be stored in the list with the allocated memory at a given time is given by:<p>
ntl-&gt;max_size 
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00285">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00267">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00229">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00528">gaussian_kernel()</a>, <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l00241">new_ntuple_list()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a22" doxytag="lsd.c::add_7tuple" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void add_7tuple </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v3</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v4</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v5</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v6</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>v7</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a 7-tuple to an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00285">285</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00222">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00267">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00221">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00220">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00287 {
00288   <span class="comment">/* check parameters */</span>
00289   <span class="keywordflow">if</span>( out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00290   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> != 7 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: the n-tuple must be a 7-tuple."</span>);
00291 
00292   <span class="comment">/* if needed, alloc more tuples to 'out' */</span>
00293   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> == out-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(out);
00294   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"add_7tuple: invalid n-tuple input."</span>);
00295 
00296   <span class="comment">/* add new 7-tuple */</span>
00297   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 0 ] = v1;
00298   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 1 ] = v2;
00299   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 2 ] = v3;
00300   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 3 ] = v4;
00301   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 4 ] = v5;
00302   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 5 ] = v6;
00303   out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[ out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> * out-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> + 6 ] = v7;
00304 
00305   <span class="comment">/* update number of tuples counter */</span>
00306   out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>++;
00307 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a22_cgraph.png" border="0" usemap="#lsd_8c_a22_cgraph_map" alt=""></center>
<map name="lsd_8c_a22_cgraph_map">
<area href="lsd_8c.html#a21" shape="rect" coords="145,7,278,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="328,33,378,59" alt="">
</map>
<a class="anchor" name="a35" doxytag="lsd.c::angle_diff" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Absolute value angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00911">911</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00109">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00091">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>.
<p>
<div class="fragment"><pre>00912 {
00913   a -= b;
00914   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00915   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00916   <span class="keywordflow">if</span>( a &lt; 0.0 ) a = -a;
00917   <span class="keywordflow">return</span> a;
00918 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="lsd.c::angle_diff_signed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double angle_diff_signed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signed angle difference. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00923">923</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00109">M_2__PI</a>, and <a class="el" href="lsd_8c-source.html#l00091">M_PI</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.
<p>
<div class="fragment"><pre>00924 {
00925   a -= b;
00926   <span class="keywordflow">while</span>( a &lt;= -<a class="code" href="lsd_8c.html#a1">M_PI</a> ) a += <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00927   <span class="keywordflow">while</span>( a &gt;   <a class="code" href="lsd_8c.html#a1">M_PI</a> ) a -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00928   <span class="keywordflow">return</span> a;
00929 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="lsd.c::dist" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double dist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes Euclidean distance between point (x1,y1) and point (x2,y2). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00187">187</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.
<p>
<div class="fragment"><pre>00188 {
00189   <span class="keywordflow">return</span> sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
00190 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="lsd.c::double_equal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int double_equal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare doubles by relative error. 
<p>
The resulting rounding error after floating point computations depend on the specific operations done. The same number computed by different algorithms could present different rounding errors. For a useful comparison, an estimation of the relative rounding error should be considered and compared to a factor times EPS. The factor should be related to the cumulated rounding error in the chain of computation. Here, as a simplification, a fixed factor is used. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00161">161</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00148">RELATIVE_ERROR_FACTOR</a>, and <a class="el" href="lsd_8c-source.html#l00099">TRUE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01279">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01257">inter_low()</a>, and <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>.
<p>
<div class="fragment"><pre>00162 {
00163   <span class="keywordtype">double</span> abs_diff,aa,bb,abs_max;
00164 
00165   <span class="comment">/* trivial case */</span>
00166   <span class="keywordflow">if</span>( a == b ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
00167 
00168   abs_diff = fabs(a-b);
00169   aa = fabs(a);
00170   bb = fabs(b);
00171   abs_max = aa &gt; bb ? aa : bb;
00172 
00173   <span class="comment">/* DBL_MIN is the smallest normalized number, thus, the smallest</span>
00174 <span class="comment">     number whose relative error is bounded by DBL_EPSILON. For</span>
00175 <span class="comment">     smaller numbers, the same quantization steps as for DBL_MIN</span>
00176 <span class="comment">     are used. Then, for smaller numbers, a meaningful "relative"</span>
00177 <span class="comment">     error should be computed by dividing the difference by DBL_MIN. */</span>
00178   <span class="keywordflow">if</span>( abs_max &lt; DBL_MIN ) abs_max = DBL_MIN;
00179 
00180   <span class="comment">/* equal if relative error &lt;= factor x eps */</span>
00181   <span class="keywordflow">return</span> (abs_diff / abs_max) &lt;= (<a class="code" href="lsd_8c.html#a9">RELATIVE_ERROR_FACTOR</a> * DBL_EPSILON);
00182 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="lsd.c::enlarge_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void enlarge_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n_tuple</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enlarge the allocated memory of an n-tuple list. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00267">267</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00222">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00221">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, and <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00285">add_7tuple()</a>, and <a class="el" href="lsd_8c-source.html#l00528">gaussian_kernel()</a>.
<p>
<div class="fragment"><pre>00268 {
00269   <span class="comment">/* check parameters */</span>
00270   <span class="keywordflow">if</span>( n_tuple == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL || n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> == 0 )
00271     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"enlarge_ntuple_list: invalid n-tuple."</span>);
00272 
00273   <span class="comment">/* duplicate number of tuples */</span>
00274   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> *= 2;
00275 
00276   <span class="comment">/* realloc memory */</span>
00277   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) realloc( (<span class="keywordtype">void</span> *) n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>,
00278                       n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> * n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00279   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00280 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a21_cgraph.png" border="0" usemap="#lsd_8c_a21_cgraph_map" alt=""></center>
<map name="lsd_8c_a21_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="192,8,242,34" alt="">
</map>
<a class="anchor" name="a16" doxytag="lsd.c::error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error, print a message to standard-error output and exit. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00139">139</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00285">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00267">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00332">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00458">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00229">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00528">gaussian_kernel()</a>, <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>, <a class="el" href="lsd_8c-source.html#l01279">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01257">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l00732">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00343">new_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00368">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00469">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00493">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l00403">new_image_int()</a>, <a class="el" href="lsd_8c-source.html#l00241">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01163">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01927">refine()</a>, <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l01294">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01305">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>, and <a class="el" href="lsd_8c-source.html#l01391">ri_ini()</a>.
<p>
<div class="fragment"><pre>00140 {
00141   fprintf(stderr,<span class="stringliteral">"LSD Error: %s\n"</span>,msg);
00142   exit(EXIT_FAILURE);
00143 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="lsd.c::free_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_char 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00332">332</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, and <a class="el" href="lsd_8c.html#a13">image_char</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00333 {
00334   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00335     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_char: invalid input image."</span>);
00336   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> );
00337   free( (<span class="keywordtype">void</span> *) i );
00338 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a23_cgraph.png" border="0" usemap="#lsd_8c_a23_cgraph_map" alt=""></center>
<map name="lsd_8c_a23_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="178,8,229,34" alt="">
</map>
<a class="anchor" name="a28" doxytag="lsd.c::free_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in image_double 'i'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00458">458</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, and <a class="el" href="lsd_8c.html#a15">image_double</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00459 {
00460   <span class="keywordflow">if</span>( i == NULL || i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00461     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_image_double: invalid input image."</span>);
00462   free( (<span class="keywordtype">void</span> *) i-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> );
00463   free( (<span class="keywordtype">void</span> *) i );
00464 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a28_cgraph.png" border="0" usemap="#lsd_8c_a28_cgraph_map" alt=""></center>
<map name="lsd_8c_a28_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a19" doxytag="lsd.c::free_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void free_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used in n-tuple 'in'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00229">229</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, and <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00230 {
00231   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00232     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"free_ntuple_list: invalid n-tuple input."</span>);
00233   free( (<span class="keywordtype">void</span> *) in-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> );
00234   free( (<span class="keywordtype">void</span> *) in );
00235 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a19_cgraph.png" border="0" usemap="#lsd_8c_a19_cgraph_map" alt=""></center>
<map name="lsd_8c_a19_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a31" doxytag="lsd.c::gaussian_kernel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void gaussian_kernel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structntuple__list__s.html">ntuple_list</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>mean</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a Gaussian kernel of length 'kernel-&gt;dim', standard deviation 'sigma', and centered at value 'mean'. 
<p>
For example, if mean=0.5, the Gaussian will be centered in the middle point between values 'kernel-&gt;values[0]' and 'kernel-&gt;values[1]'. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00528">528</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00222">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00267">enlarge_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00221">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00220">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>.
<p>
<div class="fragment"><pre>00529 {
00530   <span class="keywordtype">double</span> sum = 0.0;
00531   <span class="keywordtype">double</span> val;
00532   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00533 
00534   <span class="comment">/* check parameters */</span>
00535   <span class="keywordflow">if</span>( kernel == NULL || kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL )
00536     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: invalid n-tuple 'kernel'."</span>);
00537   <span class="keywordflow">if</span>( sigma &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_kernel: 'sigma' must be positive."</span>);
00538 
00539   <span class="comment">/* compute Gaussian kernel */</span>
00540   <span class="keywordflow">if</span>( kernel-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> &lt; 1 ) <a class="code" href="lsd_8c.html#a21">enlarge_ntuple_list</a>(kernel);
00541   kernel-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 1;
00542   <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00543     {
00544       val = ( (<span class="keywordtype">double</span>) i - mean ) / sigma;
00545       kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] = exp( -0.5 * val * val );
00546       sum += kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00547     }
00548 
00549   <span class="comment">/* normalization */</span>
00550   <span class="keywordflow">if</span>( sum &gt;= 0.0 ) <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++) kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i] /= sum;
00551 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a31_cgraph.png" border="0" usemap="#lsd_8c_a31_cgraph_map" alt=""></center>
<map name="lsd_8c_a31_cgraph_map">
<area href="lsd_8c.html#a21" shape="rect" coords="177,7,310,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="360,33,410,59" alt="">
</map>
<a class="anchor" name="a32" doxytag="lsd.c::gaussian_sampler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> gaussian_sampler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scale the input image 'in' by a factor 'scale' by Gaussian sub-sampling. 
<p>
For example, scale=0.8 will give a result at 80% of the original size.<p>
The image is convolved with a Gaussian kernel <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} \]" src="form_0.png">
<p>
 before the sub-sampling to prevent aliasing.<p>
The standard deviation sigma given by:<ul>
<li>sigma = sigma_scale / scale, if scale &lt; 1.0</li><li>sigma = sigma_scale, if scale &gt;= 1.0</li></ul>
<p>
To be able to sub-sample at non-integer steps, some interpolation is needed. In this implementation, the interpolation is done by the Gaussian kernel, so both operations (filtering and sampling) are done at the same time. The Gaussian kernel is computed centered on the coordinates of the required sample. In this way, when applied, it gives directly the result of convolving the image with the kernel and interpolated to that particular position.<p>
A fast algorithm is done using the separability of the Gaussian kernel. Applying the 2D Gaussian kernel is equivalent to applying first a horizontal 1D Gaussian kernel and then a vertical 1D Gaussian kernel (or the other way round). The reason is that <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x,y) = G(x) * G(y) \]" src="form_1.png">
<p>
 where <p class=formulaDsp>
<img class=formulaDsp alt="\[ G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}. \]" src="form_2.png">
<p>
 The algorithm first applies a combined Gaussian kernel and sampling in the x axis, and then the combined Gaussian kernel and sampling in the y axis. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00591">591</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00222">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00458">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00229">free_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00528">gaussian_kernel()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00469">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00241">new_ntuple_list()</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00593 {
00594   <a class="code" href="structimage__double__s.html">image_double</a> aux,out;
00595   <a class="code" href="structntuple__list__s.html">ntuple_list</a> kernel;
00596   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N,M,h,n,x,y,i;
00597   <span class="keywordtype">int</span> xc,yc,j,double_x_size,double_y_size;
00598   <span class="keywordtype">double</span> sigma,xx,yy,sum,prec;
00599 
00600   <span class="comment">/* check parameters */</span>
00601   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00602     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: invalid image."</span>);
00603   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'scale' must be positive."</span>);
00604   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 )
00605     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: 'sigma_scale' must be positive."</span>);
00606 
00607   <span class="comment">/* compute new image size and get memory for images */</span>
00608   <span class="keywordflow">if</span>( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX ||
00609       in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale &gt; (<span class="keywordtype">double</span>) UINT_MAX )
00610     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"gaussian_sampler: the output image size exceeds the handled size."</span>);
00611   N = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> * scale );
00612   M = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> * scale );
00613   aux = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00614   out = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(N,M);
00615 
00616   <span class="comment">/* sigma, kernel size and memory for the kernel */</span>
00617   sigma = scale &lt; 1.0 ? sigma_scale / scale : sigma_scale;
00618   <span class="comment">/*</span>
00619 <span class="comment">     The size of the kernel is selected to guarantee that the</span>
00620 <span class="comment">     the first discarded term is at least 10^prec times smaller</span>
00621 <span class="comment">     than the central value. For that, h should be larger than x, with</span>
00622 <span class="comment">       e^(-x^2/2sigma^2) = 1/10^prec.</span>
00623 <span class="comment">     Then,</span>
00624 <span class="comment">       x = sigma * sqrt( 2 * prec * ln(10) ).</span>
00625 <span class="comment">   */</span>
00626   prec = 3.0;
00627   h = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ceil( sigma * sqrt( 2.0 * prec * log(10.0) ) );
00628   n = 1+2*h; <span class="comment">/* kernel size */</span>
00629   kernel = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(n);
00630 
00631   <span class="comment">/* auxiliary double image size variables */</span>
00632   double_x_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>);
00633   double_y_size = (<span class="keywordtype">int</span>) (2 * in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00634 
00635   <span class="comment">/* First subsampling: x axis */</span>
00636   <span class="keywordflow">for</span>(x=0;x&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00637     {
00638       <span class="comment">/*</span>
00639 <span class="comment">         x   is the coordinate in the new image.</span>
00640 <span class="comment">         xx  is the corresponding x-value in the original size image.</span>
00641 <span class="comment">         xc  is the integer value, the pixel coordinate of xx.</span>
00642 <span class="comment">       */</span>
00643       xx = (<span class="keywordtype">double</span>) x / scale;
00644       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00645 <span class="comment">         so the pixel with xc=0 get the values of xx from -0.5 to 0.5 */</span>
00646       xc = (<span class="keywordtype">int</span>) floor( xx + 0.5 );
00647       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + xx - (<span class="keywordtype">double</span>) xc );
00648       <span class="comment">/* the kernel must be computed for each x because the fine</span>
00649 <span class="comment">         offset xx-xc is different in each case */</span>
00650 
00651       <span class="keywordflow">for</span>(y=0;y&lt;aux-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00652         {
00653           sum = 0.0;
00654           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00655             {
00656               j = xc - h + i;
00657 
00658               <span class="comment">/* symmetry boundary condition */</span>
00659               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_x_size;
00660               <span class="keywordflow">while</span>( j &gt;= double_x_size ) j -= double_x_size;
00661               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ) j = double_x_size-1-j;
00662 
00663               sum += in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ j + y * in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00664             }
00665           aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00666         }
00667     }
00668 
00669   <span class="comment">/* Second subsampling: y axis */</span>
00670   <span class="keywordflow">for</span>(y=0;y&lt;out-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;y++)
00671     {
00672       <span class="comment">/*</span>
00673 <span class="comment">         y   is the coordinate in the new image.</span>
00674 <span class="comment">         yy  is the corresponding x-value in the original size image.</span>
00675 <span class="comment">         yc  is the integer value, the pixel coordinate of xx.</span>
00676 <span class="comment">       */</span>
00677       yy = (<span class="keywordtype">double</span>) y / scale;
00678       <span class="comment">/* coordinate (0.0,0.0) is in the center of pixel (0,0),</span>
00679 <span class="comment">         so the pixel with yc=0 get the values of yy from -0.5 to 0.5 */</span>
00680       yc = (<span class="keywordtype">int</span>) floor( yy + 0.5 );
00681       <a class="code" href="lsd_8c.html#a31">gaussian_kernel</a>( kernel, sigma, (<span class="keywordtype">double</span>) h + yy - (<span class="keywordtype">double</span>) yc );
00682       <span class="comment">/* the kernel must be computed for each y because the fine</span>
00683 <span class="comment">         offset yy-yc is different in each case */</span>
00684 
00685       <span class="keywordflow">for</span>(x=0;x&lt;out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;x++)
00686         {
00687           sum = 0.0;
00688           <span class="keywordflow">for</span>(i=0;i&lt;kernel-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a>;i++)
00689             {
00690               j = yc - h + i;
00691 
00692               <span class="comment">/* symmetry boundary condition */</span>
00693               <span class="keywordflow">while</span>( j &lt; 0 ) j += double_y_size;
00694               <span class="keywordflow">while</span>( j &gt;= double_y_size ) j -= double_y_size;
00695               <span class="keywordflow">if</span>( j &gt;= (<span class="keywordtype">int</span>) in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> ) j = double_y_size-1-j;
00696 
00697               sum += aux-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + j * aux-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] * kernel-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>[i];
00698             }
00699           out-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * out-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] = sum;
00700         }
00701     }
00702 
00703   <span class="comment">/* free memory */</span>
00704   <a class="code" href="lsd_8c.html#a19">free_ntuple_list</a>(kernel);
00705   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(aux);
00706 
00707   <span class="keywordflow">return</span> out;
00708 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a32_cgraph.png" border="0" usemap="#lsd_8c_a32_cgraph_map" alt=""></center>
<map name="lsd_8c_a32_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="560,197,610,224" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="374,96,510,122" alt="">
<area href="lsd_8c.html#a19" shape="rect" coords="386,146,498,173" alt="">
<area href="lsd_8c.html#a31" shape="rect" coords="197,197,314,224" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="188,260,324,286" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="198,336,313,362" alt="">
<area href="lsd_8c.html#a21" shape="rect" coords="376,248,509,274" alt="">
</map>
<a class="anchor" name="a48" doxytag="lsd.c::get_theta" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double get_theta </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute region's angle as the principal inertia axis of the region. 
<p>
The following is the region inertia matrix A: <p class=formulaDsp>
<img class=formulaDsp alt="\[ A = \left(\begin{array}{cc} Ixx &amp; Ixy \\ Ixy &amp; Iyy \\ \end{array}\right) \]" src="form_10.png">
<p>
 where<p>
Ixx = sum_i G(i).(y_i - cx)^2<p>
Iyy = sum_i G(i).(x_i - cy)^2<p>
Ixy = - sum_i G(i).(x_i - cx).(y_i - cy)<p>
and<ul>
<li>G(i) is the gradient norm at pixel i, used as pixel's weight.</li><li>x_i and y_i are the coordinates of pixel i.</li><li>cx and cy are the coordinates of the center of th region.</li></ul>
<p>
lambda1 and lambda2 are the eigenvalues of matrix A, with lambda1 &gt;= lambda2. They are found by solving the characteristic polynomial:<p>
det( lambda I - A) = 0<p>
that gives:<p>
lambda1 = ( Ixx + Iyy + sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
lambda2 = ( Ixx + Iyy - sqrt( (Ixx-Iyy)^2 + 4.0*Ixy*Ixy) ) / 2<p>
To get the line segment direction we want to get the angle the eigenvector associated to the smallest eigenvalue. We have to solve for a,b in:<p>
a.Ixx + b.Ixy = a.lambda2<p>
a.Ixy + b.Iyy = b.lambda2<p>
We want the angle theta = atan(b/a). It can be computed with any of the two equations:<p>
theta = atan( (lambda2-Ixx) / Ixy )<p>
or<p>
theta = atan( Ixy / (lambda2-Iyy) )<p>
When |Ixx| &gt; |Iyy| we use the first, otherwise the second (just to get better numeric precision). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01548">1548</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00911">angle_diff()</a>, <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00091">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00129">point::x</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00129">point::y</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>.
<p>
<div class="fragment"><pre>01550 {
01551   <span class="keywordtype">double</span> lambda,theta,weight;
01552   <span class="keywordtype">double</span> Ixx = 0.0;
01553   <span class="keywordtype">double</span> Iyy = 0.0;
01554   <span class="keywordtype">double</span> Ixy = 0.0;
01555   <span class="keywordtype">int</span> i;
01556 
01557   <span class="comment">/* check parameters */</span>
01558   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid region."</span>);
01559   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: region size &lt;= 1."</span>);
01560   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01561     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: invalid 'modgrad'."</span>);
01562   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: 'prec' must be positive."</span>);
01563 
01564   <span class="comment">/* compute inertia matrix */</span>
01565   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01566     {
01567       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01568       Ixx += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01569       Iyy += ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * weight;
01570       Ixy -= ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x ) * ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y ) * weight;
01571     }
01572   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixx,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Iyy,0.0) &amp;&amp; <a class="code" href="lsd_8c.html#a17">double_equal</a>(Ixy,0.0) )
01573     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"get_theta: null inertia matrix."</span>);
01574 
01575   <span class="comment">/* compute smallest eigenvalue */</span>
01576   lambda = 0.5 * ( Ixx + Iyy - sqrt( (Ixx-Iyy)*(Ixx-Iyy) + 4.0*Ixy*Ixy ) );
01577 
01578   <span class="comment">/* compute angle */</span>
01579   theta = fabs(Ixx)&gt;fabs(Iyy) ? atan2(lambda-Ixx,Ixy) : atan2(Ixy,lambda-Iyy);
01580 
01581   <span class="comment">/* The previous procedure doesn't cares about orientation,</span>
01582 <span class="comment">     so it could be wrong by 180 degrees. Here is corrected if necessary. */</span>
01583   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a35">angle_diff</a>(theta,reg_angle) &gt; prec ) theta += <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01584 
01585   <span class="keywordflow">return</span> theta;
01586 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a48_cgraph.png" border="0" usemap="#lsd_8c_a48_cgraph_map" alt=""></center>
<map name="lsd_8c_a48_cgraph_map">
<area href="lsd_8c.html#a35" shape="rect" coords="145,8,225,34" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="134,58,235,85" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="159,109,210,136" alt="">
</map>
<a class="anchor" name="a42" doxytag="lsd.c::inter_hi" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_hi </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the larger of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01279">1279</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00139">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>.
<p>
<div class="fragment"><pre>01280 {
01281   <span class="comment">/* check parameters */</span>
01282   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01283     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_hi: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01284 
01285   <span class="comment">/* interpolation */</span>
01286   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y2;
01287   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y1;
01288   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01289 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a42_cgraph.png" border="0" usemap="#lsd_8c_a42_cgraph_map" alt=""></center>
<map name="lsd_8c_a42_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="124,7,225,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="149,58,200,85" alt="">
</map>
<a class="anchor" name="a41" doxytag="lsd.c::inter_low" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double inter_low </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'. 
<p>
The following restrictions are required:<ul>
<li>x1 &lt;= x2</li><li>x1 &lt;= x</li><li>x &lt;= x2 </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01257">1257</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>, and <a class="el" href="lsd_8c-source.html#l00139">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>.
<p>
<div class="fragment"><pre>01258 {
01259   <span class="comment">/* check parameters */</span>
01260   <span class="keywordflow">if</span>( x1 &gt; x2 || x &lt; x1 || x &gt; x2 )
01261     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"inter_low: unsuitable input, 'x1&gt;x2' or 'x&lt;x1' or 'x&gt;x2'."</span>);
01262 
01263   <span class="comment">/* interpolation */</span>
01264   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&lt;y2 ) <span class="keywordflow">return</span> y1;
01265   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(x1,x2) &amp;&amp; y1&gt;y2 ) <span class="keywordflow">return</span> y2;
01266   <span class="keywordflow">return</span> y1 + (x-x1) * (y2-y1) / (x2-x1);
01267 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a41_cgraph.png" border="0" usemap="#lsd_8c_a41_cgraph_map" alt=""></center>
<map name="lsd_8c_a41_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="134,7,235,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="159,58,210,85" alt="">
</map>
<a class="anchor" name="a34" doxytag="lsd.c::isaligned" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int isaligned </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>theta</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Is point (x,y) aligned to angle theta, up to precision 'prec'? 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00873">873</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00095">FALSE</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00109">M_2__PI</a>, <a class="el" href="lsd_8c-source.html#l00106">M_3_2_PI</a>, <a class="el" href="lsd_8c-source.html#l00103">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>.
<p>
<div class="fragment"><pre>00875 {
00876   <span class="keywordtype">double</span> a;
00877 
00878   <span class="comment">/* check parameters */</span>
00879   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
00880     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: invalid image 'angles'."</span>);
00881   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
00882     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: (x,y) out of the image."</span>);
00883   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"isaligned: 'prec' must be positive."</span>);
00884 
00885   <span class="comment">/* angle at pixel (x,y) */</span>
00886   a = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ x + y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
00887 
00888   <span class="comment">/* pixels whose level-line angle is not defined</span>
00889 <span class="comment">     are considered as NON-aligned */</span>
00890   <span class="keywordflow">if</span>( a == <a class="code" href="lsd_8c.html#a4">NOTDEF</a> ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;  <span class="comment">/* there is no need to call the function</span>
00891 <span class="comment">                                      'double_equal' here because there is</span>
00892 <span class="comment">                                      no risk of problems related to the</span>
00893 <span class="comment">                                      comparison doubles, we are only</span>
00894 <span class="comment">                                      interested in the exact NOTDEF value */</span>
00895 
00896   <span class="comment">/* it is assumed that 'theta' and 'a' are in the range [-pi,pi] */</span>
00897   theta -= a;
00898   <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00899   <span class="keywordflow">if</span>( theta &gt; <a class="code" href="lsd_8c.html#a5">M_3_2_PI</a> )
00900     {
00901       theta -= <a class="code" href="lsd_8c.html#a6">M_2__PI</a>;
00902       <span class="keywordflow">if</span>( theta &lt; 0.0 ) theta = -theta;
00903     }
00904 
00905   <span class="keywordflow">return</span> theta &lt;= prec;
00906 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a34_cgraph.png" border="0" usemap="#lsd_8c_a34_cgraph_map" alt=""></center>
<map name="lsd_8c_a34_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="130,8,181,34" alt="">
</map>
<a class="anchor" name="a54" doxytag="lsd.c::LineSegmentDetection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* LineSegmentDetection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>sigma_scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>quant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>ang_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>log_eps</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Full Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>sigma_scale</em>&nbsp;</td><td>When scale!=1.0, the sigma of the Gaussian filter is: sigma = sigma_scale / scale, if scale &lt; 1.0 sigma = sigma_scale, if scale &gt;= 1.0 Suggested value: 0.6</td></tr>
    <tr><td valign=top><em>quant</em>&nbsp;</td><td>Bound to the quantization error on the gradient norm. Example: if gray levels are quantized to integer steps, the gradient (computed by finite differences) error due to quantization will be bounded by 2.0, as the worst case is when the error are 1 and -1, that gives an error of 2.0. Suggested value: 2.0</td></tr>
    <tr><td valign=top><em>ang_th</em>&nbsp;</td><td>Gradient angle tolerance in the region growing algorithm, in degrees. Suggested value: 22.5</td></tr>
    <tr><td valign=top><em>log_eps</em>&nbsp;</td><td>Detection threshold, accept if -log10(NFA) &gt; log_eps. The larger the value, the more strict the detector is, and will result in less detections. (Note that the 'minus sign' makes that this behavior is opposite to the one of NFA.) The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1.0 gives an average of 10 false detections on noise</li><li>0.0 gives an average of 1 false detections on noise</li><li>1.0 gives an average of 0.1 false detections on nose</li><li>2.0 gives an average of 0.01 false detections on noise</li></ul>
Suggested value: 0.0</td></tr>
    <tr><td valign=top><em>density_th</em>&nbsp;</td><td>Minimal proportion of 'supporting' points in a rectangle. Suggested value: 0.7</td></tr>
    <tr><td valign=top><em>n_bins</em>&nbsp;</td><td>Number of bins used in the pseudo-ordering of gradient modulus. Suggested value: 1024</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02005">2005</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00285">add_7tuple()</a>, <a class="el" href="lsd_8c-source.html#l00396">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00332">free_image_char()</a>, <a class="el" href="lsd_8c-source.html#l00458">free_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, <a class="el" href="lsd_8c-source.html#l00732">ll_angle()</a>, <a class="el" href="lsd_8c-source.html#l00091">M_PI</a>, <a class="el" href="lsd_8c-source.html#l00368">new_image_char_ini()</a>, <a class="el" href="lsd_8c-source.html#l00493">new_image_double_ptr()</a>, <a class="el" href="lsd_8c-source.html#l00427">new_image_int_ini()</a>, <a class="el" href="lsd_8c-source.html#l00241">new_ntuple_list()</a>, <a class="el" href="lsd_8c-source.html#l00103">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00112">NOTUSED</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l01157">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01736">rect_improve()</a>, <a class="el" href="lsd_8c-source.html#l01927">refine()</a>, <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00220">ntuple_list_s::size</a>, <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00397">image_int_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l00397">image_int_s::ysize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02192">lsd_scale_region()</a>.
<p>
<div class="fragment"><pre>02011 {
02012   <a class="code" href="structimage__double__s.html">image_double</a> image;
02013   <a class="code" href="structntuple__list__s.html">ntuple_list</a> out = <a class="code" href="lsd_8c.html#a20">new_ntuple_list</a>(7);
02014   <span class="keywordtype">double</span> * return_value;
02015   <a class="code" href="structimage__double__s.html">image_double</a> scaled_image,angles,modgrad;
02016   <a class="code" href="structimage__char__s.html">image_char</a> used;
02017   <a class="code" href="structimage__int__s.html">image_int</a> region = NULL;
02018   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list_p;
02019   <span class="keywordtype">void</span> * mem_p;
02020   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> rec;
02021   <span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> * reg;
02022   <span class="keywordtype">int</span> reg_size,min_reg_size,i;
02023   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xsize,ysize;
02024   <span class="keywordtype">double</span> rho,reg_angle,prec,p,log_nfa,logNT;
02025   <span class="keywordtype">int</span> ls_count = 0;                   <span class="comment">/* line segments are numbered 1,2,3,... */</span>
02026 
02027 
02028   <span class="comment">/* check parameters */</span>
02029   <span class="keywordflow">if</span>( img == NULL || X &lt;= 0 || Y &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"invalid image input."</span>);
02030   <span class="keywordflow">if</span>( scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'scale' value must be positive."</span>);
02031   <span class="keywordflow">if</span>( sigma_scale &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'sigma_scale' value must be positive."</span>);
02032   <span class="keywordflow">if</span>( quant &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'quant' value must be positive."</span>);
02033   <span class="keywordflow">if</span>( ang_th &lt;= 0.0 || ang_th &gt;= 180.0 )
02034     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'ang_th' value must be in the range (0,180)."</span>);
02035   <span class="keywordflow">if</span>( density_th &lt; 0.0 || density_th &gt; 1.0 )
02036     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'density_th' value must be in the range [0,1]."</span>);
02037   <span class="keywordflow">if</span>( n_bins &lt;= 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'n_bins' value must be positive."</span>);
02038 
02039 
02040   <span class="comment">/* angle tolerance */</span>
02041   prec = <a class="code" href="lsd_8c.html#a1">M_PI</a> * ang_th / 180.0;
02042   p = ang_th / 180.0;
02043   rho = quant / sin(prec); <span class="comment">/* gradient magnitude threshold */</span>
02044 
02045 
02046   <span class="comment">/* load and scale image (if necessary) and compute angle at each pixel */</span>
02047   image = <a class="code" href="lsd_8c.html#a30">new_image_double_ptr</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) X, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) Y, img );
02048   <span class="keywordflow">if</span>( scale != 1.0 )
02049     {
02050       scaled_image = <a class="code" href="lsd_8c.html#a32">gaussian_sampler</a>( image, scale, sigma_scale );
02051       angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( scaled_image, rho, &amp;list_p, &amp;mem_p,
02052                          &amp;modgrad, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02053       <a class="code" href="lsd_8c.html#a28">free_image_double</a>(scaled_image);
02054     }
02055   <span class="keywordflow">else</span>
02056     angles = <a class="code" href="lsd_8c.html#a33">ll_angle</a>( image, rho, &amp;list_p, &amp;mem_p, &amp;modgrad,
02057                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n_bins );
02058   xsize = angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
02059   ysize = angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
02060 
02061   <span class="comment">/* Number of Tests - NT</span>
02062 <span class="comment"></span>
02063 <span class="comment">     The theoretical number of tests is Np.(XY)^(5/2)</span>
02064 <span class="comment">     where X and Y are number of columns and rows of the image.</span>
02065 <span class="comment">     Np corresponds to the number of angle precisions considered.</span>
02066 <span class="comment">     As the procedure 'rect_improve' tests 5 times to halve the</span>
02067 <span class="comment">     angle precision, and 5 more times after improving other factors,</span>
02068 <span class="comment">     11 different precision values are potentially tested. Thus,</span>
02069 <span class="comment">     the number of tests is</span>
02070 <span class="comment">       11 * (X*Y)^(5/2)</span>
02071 <span class="comment">     whose logarithm value is</span>
02072 <span class="comment">       log10(11) + 5/2 * (log10(X) + log10(Y)).</span>
02073 <span class="comment">  */</span>
02074   logNT = 5.0 * ( log10( (<span class="keywordtype">double</span>) xsize ) + log10( (<span class="keywordtype">double</span>) ysize ) ) / 2.0
02075           + log10(11.0);
02076   min_reg_size = (<span class="keywordtype">int</span>) (-logNT/log10(p)); <span class="comment">/* minimal number of points in region</span>
02077 <span class="comment">                                             that can give a meaningful event */</span>
02078 
02079 
02080   <span class="comment">/* initialize some structures */</span>
02081   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL ) <span class="comment">/* save region data */</span>
02082     region = <a class="code" href="lsd_8c.html#a27">new_image_int_ini</a>(angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>,0);
02083   used = <a class="code" href="lsd_8c.html#a25">new_image_char_ini</a>(xsize,ysize,NOTUSED);
02084   reg = (<span class="keyword">struct </span><a class="code" href="structpoint.html">point</a> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structpoint.html">point</a>) );
02085   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory!"</span>);
02086 
02087 
02088   <span class="comment">/* search for line segments */</span>
02089   <span class="keywordflow">for</span>(; list_p != NULL; list_p = list_p-&gt;next )
02090     <span class="keywordflow">if</span>( used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] == <a class="code" href="lsd_8c.html#a7">NOTUSED</a> &amp;&amp;
02091         angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ list_p-&gt;x + list_p-&gt;y * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ] != <a class="code" href="lsd_8c.html#a4">NOTDEF</a> )
02092        <span class="comment">/* there is no risk of double comparison problems here</span>
02093 <span class="comment">          because we are only interested in the exact NOTDEF value */</span>
02094       {
02095         <span class="comment">/* find the region of connected point and ~equal angle */</span>
02096         <a class="code" href="lsd_8c.html#a50">region_grow</a>( list_p-&gt;x, list_p-&gt;y, angles, reg, &amp;reg_size,
02097                      &amp;reg_angle, used, prec );
02098 
02099         <span class="comment">/* reject small regions */</span>
02100         <span class="keywordflow">if</span>( reg_size &lt; min_reg_size ) <span class="keywordflow">continue</span>;
02101 
02102         <span class="comment">/* construct rectangular approximation for the region */</span>
02103         <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,reg_size,modgrad,reg_angle,prec,p,&amp;rec);
02104 
02105         <span class="comment">/* Check if the rectangle exceeds the minimal density of</span>
02106 <span class="comment">           region points. If not, try to improve the region.</span>
02107 <span class="comment">           The rectangle will be rejected if the final one does</span>
02108 <span class="comment">           not fulfill the minimal density condition.</span>
02109 <span class="comment">           This is an addition to the original LSD algorithm published in</span>
02110 <span class="comment">           "LSD: A Fast Line Segment Detector with a False Detection Control"</span>
02111 <span class="comment">           by R. Grompone von Gioi, J. Jakubowicz, J.M. Morel, and G. Randall.</span>
02112 <span class="comment">           The original algorithm is obtained with density_th = 0.0.</span>
02113 <span class="comment">         */</span>
02114         <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a53">refine</a>( reg, &amp;reg_size, modgrad, reg_angle,
02115                      prec, p, &amp;rec, used, angles, density_th ) ) <span class="keywordflow">continue</span>;
02116 
02117         <span class="comment">/* compute NFA value */</span>
02118         log_nfa = <a class="code" href="lsd_8c.html#a51">rect_improve</a>(&amp;rec,angles,logNT,log_eps);
02119         <span class="keywordflow">if</span>( log_nfa &lt;= log_eps ) <span class="keywordflow">continue</span>;
02120 
02121         <span class="comment">/* A New Line Segment was found! */</span>
02122         ++ls_count;  <span class="comment">/* increase line segment counter */</span>
02123 
02124         <span class="comment">/*</span>
02125 <span class="comment">           The gradient was computed with a 2x2 mask, its value corresponds to</span>
02126 <span class="comment">           points with an offset of (0.5,0.5), that should be added to output.</span>
02127 <span class="comment">           The coordinates origin is at the center of pixel (0,0).</span>
02128 <span class="comment">         */</span>
02129         rec.<a class="code" href="structrect.html#o0">x1</a> += 0.5; rec.<a class="code" href="structrect.html#o1">y1</a> += 0.5;
02130         rec.<a class="code" href="structrect.html#o2">x2</a> += 0.5; rec.<a class="code" href="structrect.html#o3">y2</a> += 0.5;
02131 
02132         <span class="comment">/* scale the result values if a subsampling was performed */</span>
02133         <span class="keywordflow">if</span>( scale != 1.0 )
02134           {
02135             rec.<a class="code" href="structrect.html#o0">x1</a> /= scale; rec.<a class="code" href="structrect.html#o1">y1</a> /= scale;
02136             rec.<a class="code" href="structrect.html#o2">x2</a> /= scale; rec.<a class="code" href="structrect.html#o3">y2</a> /= scale;
02137             rec.<a class="code" href="structrect.html#o4">width</a> /= scale;
02138           }
02139 
02140         <span class="comment">/* add line segment found to output */</span>
02141         <a class="code" href="lsd_8c.html#a22">add_7tuple</a>( out, rec.<a class="code" href="structrect.html#o0">x1</a>, rec.<a class="code" href="structrect.html#o1">y1</a>, rec.<a class="code" href="structrect.html#o2">x2</a>, rec.<a class="code" href="structrect.html#o3">y2</a>,
02142                          rec.<a class="code" href="structrect.html#o4">width</a>, rec.<a class="code" href="structrect.html#o11">p</a>, log_nfa );
02143 
02144         <span class="comment">/* add region number to 'region' image if needed */</span>
02145         <span class="keywordflow">if</span>( region != NULL )
02146           <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
02147             region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[ reg[i].x + reg[i].y * region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> ] = ls_count;
02148       }
02149 
02150 
02151   <span class="comment">/* free memory */</span>
02152   free( (<span class="keywordtype">void</span> *) image );   <span class="comment">/* only the double_image structure should be freed,</span>
02153 <span class="comment">                               the data pointer was provided to this functions</span>
02154 <span class="comment">                               and should not be destroyed.                 */</span>
02155   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(angles);
02156   <a class="code" href="lsd_8c.html#a28">free_image_double</a>(modgrad);
02157   <a class="code" href="lsd_8c.html#a23">free_image_char</a>(used);
02158   free( (<span class="keywordtype">void</span> *) reg );
02159   free( (<span class="keywordtype">void</span> *) mem_p );
02160 
02161   <span class="comment">/* return the result */</span>
02162   <span class="keywordflow">if</span>( reg_img != NULL &amp;&amp; reg_x != NULL &amp;&amp; reg_y != NULL )
02163     {
02164       <span class="keywordflow">if</span>( region == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"'region' should be a valid image."</span>);
02165       *reg_img = region-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>;
02166       <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX ||
02167           region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02168         <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region image to big to fit in INT sizes."</span>);
02169       *reg_x = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a>);
02170       *reg_y = (<span class="keywordtype">int</span>) (region-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a>);
02171 
02172       <span class="comment">/* free the 'region' structure.</span>
02173 <span class="comment">         we cannot use the function 'free_image_int' because we need to keep</span>
02174 <span class="comment">         the memory with the image data to be returned by this function. */</span>
02175       free( (<span class="keywordtype">void</span> *) region );
02176     }
02177   <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) INT_MAX )
02178     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"too many detections to fit in an INT."</span>);
02179   *n_out = (<span class="keywordtype">int</span>) (out-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a>);
02180 
02181   return_value = out-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a>;
02182   free( (<span class="keywordtype">void</span> *) out );  <span class="comment">/* only the 'ntuple_list' structure must be freed,</span>
02183 <span class="comment">                            but the 'values' pointer must be keep to return</span>
02184 <span class="comment">                            as a result. */</span>
02185 
02186   <span class="keywordflow">return</span> return_value;
02187 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a54_cgraph.png" border="0" usemap="#lsd_8c_a54_cgraph_map" alt=""></center>
<map name="lsd_8c_a54_cgraph_map">
<area href="lsd_8c.html#a22" shape="rect" coords="449,7,537,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="610,286,661,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="431,109,554,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="425,159,561,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="229,210,359,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="435,261,550,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="459,311,526,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="222,362,366,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="214,413,374,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="227,463,361,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="245,514,343,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="266,615,322,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="449,539,537,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="446,641,539,667" alt="">
</map>
<a class="anchor" name="a33" doxytag="lsd.c::ll_angle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> ll_angle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structcoorlist.html">coorlist</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>list_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>mem_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>n_bins</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the direction of the level line of 'in' at each point. 
<p>
The result is:<ul>
<li>an image_double with the angle at each pixel, or NOTDEF if not defined.</li><li>the image_double 'modgrad' (a pointer is passed as argument) with the gradient magnitude at each point.</li><li>a list of pixels 'list_p' roughly ordered by decreasing gradient magnitude. (The order is made by classifying points into bins by gradient magnitude. The parameters 'n_bins' and 'max_grad' specify the number of bins and the gradient modulus at the highest bin. The pixels in the list would be in decreasing gradient magnitude, up to a precision of the size of the bins.)</li><li>a pointer 'mem_p' to the memory used by 'list_p' to be able to free the memory when it is not used anymore. </li></ul>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00732">732</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00469">new_image_double()</a>, <a class="el" href="lsd_8c-source.html#l00103">NOTDEF</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00735 {
00736   <a class="code" href="structimage__double__s.html">image_double</a> g;
00737   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,p,x,y,adr,i;
00738   <span class="keywordtype">double</span> com1,com2,gx,gy,norm,norm2;
00739   <span class="comment">/* the rest of the variables are used for pseudo-ordering</span>
00740 <span class="comment">     the gradient magnitude values */</span>
00741   <span class="keywordtype">int</span> list_count = 0;
00742   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * list;
00743   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_s; <span class="comment">/* array of pointers to start of bin list */</span>
00744   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> ** range_l_e; <span class="comment">/* array of pointers to end of bin list */</span>
00745   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * start;
00746   <span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> * end;
00747   <span class="keywordtype">double</span> max_grad = 0.0;
00748 
00749   <span class="comment">/* check parameters */</span>
00750   <span class="keywordflow">if</span>( in == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL || in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> == 0 || in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> == 0 )
00751     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: invalid image."</span>);
00752   <span class="keywordflow">if</span>( threshold &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'threshold' must be positive."</span>);
00753   <span class="keywordflow">if</span>( list_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'list_p'."</span>);
00754   <span class="keywordflow">if</span>( mem_p == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'mem_p'."</span>);
00755   <span class="keywordflow">if</span>( modgrad == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: NULL pointer 'modgrad'."</span>);
00756   <span class="keywordflow">if</span>( n_bins == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ll_angle: 'n_bins' must be positive."</span>);
00757 
00758   <span class="comment">/* image size shortcuts */</span>
00759   n = in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>;
00760   p = in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>;
00761 
00762   <span class="comment">/* allocate output image */</span>
00763   g = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00764 
00765   <span class="comment">/* get memory for the image of gradient modulus */</span>
00766   *modgrad = <a class="code" href="lsd_8c.html#a29">new_image_double</a>(in-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>,in-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a>);
00767 
00768   <span class="comment">/* get memory for "ordered" list of pixels */</span>
00769   list = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> *) calloc( (size_t) (n*p), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a>) );
00770   *mem_p = (<span class="keywordtype">void</span> *) list;
00771   range_l_s = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00772                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00773   range_l_e = (<span class="keyword">struct </span><a class="code" href="structcoorlist.html">coorlist</a> **) calloc( (size_t) n_bins,
00774                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcoorlist.html">coorlist</a> *) );
00775   <span class="keywordflow">if</span>( list == NULL || range_l_s == NULL || range_l_e == NULL )
00776     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00777   <span class="keywordflow">for</span>(i=0;i&lt;n_bins;i++) range_l_s[i] = range_l_e[i] = NULL;
00778 
00779   <span class="comment">/* 'undefined' on the down and right boundaries */</span>
00780   <span class="keywordflow">for</span>(x=0;x&lt;p;x++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[(n-1)*p+x] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00781   <span class="keywordflow">for</span>(y=0;y&lt;n;y++) g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[p*y+p-1]   = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>;
00782 
00783   <span class="comment">/* compute gradient on the remaining pixels */</span>
00784   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00785     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00786       {
00787         adr = y*p+x;
00788 
00789         <span class="comment">/*</span>
00790 <span class="comment">           Norm 2 computation using 2x2 pixel window:</span>
00791 <span class="comment">             A B</span>
00792 <span class="comment">             C D</span>
00793 <span class="comment">           and</span>
00794 <span class="comment">             com1 = D-A,  com2 = B-C.</span>
00795 <span class="comment">           Then</span>
00796 <span class="comment">             gx = B+D - (A+C)   horizontal difference</span>
00797 <span class="comment">             gy = C+D - (A+B)   vertical difference</span>
00798 <span class="comment">           com1 and com2 are just to avoid 2 additions.</span>
00799 <span class="comment">         */</span>
00800         com1 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p+1] - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr];
00801         com2 = in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+1]   - in-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr+p];
00802 
00803         gx = com1+com2; <span class="comment">/* gradient x component */</span>
00804         gy = com1-com2; <span class="comment">/* gradient y component */</span>
00805         norm2 = gx*gx+gy*gy;
00806         norm = sqrt( norm2 / 4.0 ); <span class="comment">/* gradient norm */</span>
00807 
00808         (*modgrad)-&gt;data[adr] = norm; <span class="comment">/* store gradient norm */</span>
00809 
00810         <span class="keywordflow">if</span>( norm &lt;= threshold ) <span class="comment">/* norm too small, gradient no defined */</span>
00811           g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = <a class="code" href="lsd_8c.html#a4">NOTDEF</a>; <span class="comment">/* gradient angle not defined */</span>
00812         <span class="keywordflow">else</span>
00813           {
00814             <span class="comment">/* gradient angle computation */</span>
00815             g-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[adr] = atan2(gx,-gy);
00816 
00817             <span class="comment">/* look for the maximum of the gradient */</span>
00818             <span class="keywordflow">if</span>( norm &gt; max_grad ) max_grad = norm;
00819           }
00820       }
00821 
00822   <span class="comment">/* compute histogram of gradient values */</span>
00823   <span class="keywordflow">for</span>(x=0;x&lt;p-1;x++)
00824     <span class="keywordflow">for</span>(y=0;y&lt;n-1;y++)
00825       {
00826         norm = (*modgrad)-&gt;data[y*p+x];
00827 
00828         <span class="comment">/* store the point in the right bin according to its norm */</span>
00829         i = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (norm * (<span class="keywordtype">double</span>) n_bins / max_grad);
00830         <span class="keywordflow">if</span>( i &gt;= n_bins ) i = n_bins-1;
00831         <span class="keywordflow">if</span>( range_l_e[i] == NULL )
00832           range_l_s[i] = range_l_e[i] = list+list_count++;
00833         <span class="keywordflow">else</span>
00834           {
00835             range_l_e[i]-&gt;next = list+list_count;
00836             range_l_e[i] = list+list_count++;
00837           }
00838         range_l_e[i]-&gt;x = (<span class="keywordtype">int</span>) x;
00839         range_l_e[i]-&gt;y = (<span class="keywordtype">int</span>) y;
00840         range_l_e[i]-&gt;next = NULL;
00841       }
00842 
00843   <span class="comment">/* Make the list of pixels (almost) ordered by norm value.</span>
00844 <span class="comment">     It starts by the larger bin, so the list starts by the</span>
00845 <span class="comment">     pixels with the highest gradient value. Pixels would be ordered</span>
00846 <span class="comment">     by norm value, up to a precision given by max_grad/n_bins.</span>
00847 <span class="comment">   */</span>
00848   <span class="keywordflow">for</span>(i=n_bins-1; i&gt;0 &amp;&amp; range_l_s[i]==NULL; i--);
00849   start = range_l_s[i];
00850   end = range_l_e[i];
00851   <span class="keywordflow">if</span>( start != NULL )
00852     <span class="keywordflow">while</span>(i&gt;0)
00853       {
00854         --i;
00855         <span class="keywordflow">if</span>( range_l_s[i] != NULL )
00856           {
00857             end-&gt;next = range_l_s[i];
00858             end = range_l_e[i];
00859           }
00860       }
00861   *list_p = start;
00862 
00863   <span class="comment">/* free memory */</span>
00864   free( (<span class="keywordtype">void</span> *) range_l_s );
00865   free( (<span class="keywordtype">void</span> *) range_l_e );
00866 
00867   <span class="keywordflow">return</span> g;
00868 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a33_cgraph.png" border="0" usemap="#lsd_8c_a33_cgraph_map" alt=""></center>
<map name="lsd_8c_a33_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="312,33,362,59" alt="">
<area href="lsd_8c.html#a29" shape="rect" coords="126,58,262,85" alt="">
</map>
<a class="anchor" name="a37" doxytag="lsd.c::log_gamma_lanczos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_lanczos </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using the Lanczos approximation. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \frac{ \sum_{n=0}^{N} q_n x^n }{ \Pi_{n=0}^{N} (x+n) } (x+5.5)^{x+0.5} e^{-(x+5.5)} \]" src="form_3.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = \log\left( \sum_{n=0}^{N} q_n x^n \right) + (x+0.5) \log(x+5.5) - (x+5.5) - \sum_{n=0}^{N} \log(x+n) \]" src="form_4.png">
<p>
 and q0 = 75122.6331530, q1 = 80916.6278952, q2 = 36308.2951477, q3 = 8687.24529705, q4 = 1168.92649479, q5 = 83.8676043424, q6 = 2.50662827511. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00960">960</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>00961 {
00962   <span class="keyword">static</span> <span class="keywordtype">double</span> q[7] = { 75122.6331530, 80916.6278952, 36308.2951477,
00963                          8687.24529705, 1168.92649479, 83.8676043424,
00964                          2.50662827511 };
00965   <span class="keywordtype">double</span> a = (x+0.5) * log(x+5.5) - (x+5.5);
00966   <span class="keywordtype">double</span> b = 0.0;
00967   <span class="keywordtype">int</span> n;
00968 
00969   <span class="keywordflow">for</span>(n=0;n&lt;7;n++)
00970     {
00971       a -= log( x + (<span class="keywordtype">double</span>) n );
00972       b += q[n] * pow( x, (<span class="keywordtype">double</span>) n );
00973     }
00974   <span class="keywordflow">return</span> a + log(b);
00975 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="lsd.c::log_gamma_windschitl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double log_gamma_windschitl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the natural logarithm of the absolute value of the gamma function of x using Windschitl method. 
<p>
See <a href="http://www.rskey.org/gamma.htm">http://www.rskey.org/gamma.htm</a><p>
The formula used is <p class=formulaDsp>
<img class=formulaDsp alt="\[ \Gamma(x) = \sqrt{\frac{2\pi}{x}} \left( \frac{x}{e} \sqrt{ x\sinh(1/x) + \frac{1}{810x^6} } \right)^x \]" src="form_5.png">
<p>
 so <p class=formulaDsp>
<img class=formulaDsp alt="\[ \log\Gamma(x) = 0.5\log(2\pi) + (x-0.5)\log(x) - x + 0.5x\log\left( x\sinh(1/x) + \frac{1}{810x^6} \right). \]" src="form_6.png">
<p>
 This formula is a good approximation when x &gt; 15. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00994">994</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
<div class="fragment"><pre>00995 {
00996   <span class="keywordflow">return</span> 0.918938533204673 + (x-0.5)*log(x) - x
00997          + 0.5*x*log( x*sinh(1/x) + 1/(810.0*pow(x,6.0)) );
00998 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="lsd.c::lsd" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02223">2223</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02215">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02224 {
02225   <span class="comment">/* LSD parameters */</span>
02226   <span class="keywordtype">double</span> scale = 0.8;       <span class="comment">/* Scale the image by Gaussian filter to 'scale'. */</span>
02227 
02228   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a56">lsd_scale</a>(n_out,img,X,Y,scale);
02229 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a57_cgraph.png" border="0" usemap="#lsd_8c_a57_cgraph_map" alt=""></center>
<map name="lsd_8c_a57_cgraph_map">
<area href="lsd_8c.html#a56" shape="rect" coords="95,8,173,34" alt="">
<area href="lsd_8c.html#a55" shape="rect" coords="221,8,343,34" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="391,8,549,34" alt="">
</map>
<a class="anchor" name="a56" doxytag="lsd.c::lsd_scale" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02215">2215</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02192">lsd_scale_region()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02223">lsd()</a>.
<p>
<div class="fragment"><pre>02216 {
02217   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a55">lsd_scale_region</a>(n_out,img,X,Y,scale,NULL,NULL,NULL);
02218 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a56_cgraph.png" border="0" usemap="#lsd_8c_a56_cgraph_map" alt=""></center>
<map name="lsd_8c_a56_cgraph_map">
<area href="lsd_8c.html#a55" shape="rect" coords="133,337,255,363" alt="">
<area href="lsd_8c.html#a54" shape="rect" coords="303,337,461,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="745,7,833,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="906,286,957,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="727,109,850,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="721,159,857,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="525,210,655,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="731,261,846,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="755,311,822,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="518,362,662,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="510,413,670,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="523,463,657,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="541,514,639,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="562,615,618,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="745,539,833,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="742,641,835,667" alt="">
</map>
<a class="anchor" name="a55" doxytag="lsd.c::lsd_scale_region" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double* lsd_scale_region </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap> <em>n_out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_img</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
LSD Simple Interface with Scale and Region output. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n_out</em>&nbsp;</td><td>Pointer to an int where LSD will store the number of line segments detected.</td></tr>
    <tr><td valign=top><em>img</em>&nbsp;</td><td>Pointer to input image data. It must be an array of doubles of size X x Y, and the pixel at coordinates (x,y) is obtained by img[x+y*X].</td></tr>
    <tr><td valign=top><em>X</em>&nbsp;</td><td>X size of the image: the number of columns.</td></tr>
    <tr><td valign=top><em>Y</em>&nbsp;</td><td>Y size of the image: the number of rows.</td></tr>
    <tr><td valign=top><em>scale</em>&nbsp;</td><td>When different from 1.0, LSD will scale the input image by 'scale' factor by Gaussian filtering, before detecting line segments. Example: if scale=0.8, the input image will be subsampled to 80% of its size, before the line segment detector is applied. Suggested value: 0.8</td></tr>
    <tr><td valign=top><em>reg_img</em>&nbsp;</td><td>Optional output: if desired, LSD will return an int image where each pixel indicates the line segment to which it belongs. Unused pixels have the value '0', while the used ones have the number of the line segment, numbered 1,2,3,..., in the same order as in the output list. If desired, a non NULL int** pointer must be assigned, and LSD will make that the pointer point to an int array of size reg_x x reg_y, where the pixel value at (x,y) is obtained with (*reg_img)[x+y*reg_x]. Note that the resulting image has the size of the image used for the processing, that is, the size of the input image scaled by the given factor 'scale'. If scale!=1 this size differs from XxY and that is the reason why its value is given by reg_x and reg_y. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_x</em>&nbsp;</td><td>Pointer to an int where LSD will put the X size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
    <tr><td valign=top><em>reg_y</em>&nbsp;</td><td>Pointer to an int where LSD will put the Y size 'reg_img' image, when asked for. Suggested value: NULL</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A double array of size 7 x n_out, containing the list of line segments detected. The array contains first 7 values of line segment number 1, then the 7 values of line segment number 2, and so on, and it finish by the 7 values of line segment number n_out. The seven values are:<ul>
<li>x1,y1,x2,y2,width,p,-log10(NFA)</li></ul>
for a line segment from coordinates (x1,y1) to (x2,y2), a width 'width', an angle precision of p in (0,1) given by angle_tolerance/180 degree, and NFA value 'NFA'. If 'out' is the returned pointer, the 7 values of line segment number 'n+1' are obtained with 'out[7*n+0]' to 'out[7*n+6]'. </dd></dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l02192">2192</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02215">lsd_scale()</a>.
<p>
<div class="fragment"><pre>02195 {
02196   <span class="comment">/* LSD parameters */</span>
02197   <span class="keywordtype">double</span> sigma_scale = 0.6; <span class="comment">/* Sigma for Gaussian filter is computed as</span>
02198 <span class="comment">                                sigma = sigma_scale/scale.                    */</span>
02199   <span class="keywordtype">double</span> quant = 2.0;       <span class="comment">/* Bound to the quantization error on the</span>
02200 <span class="comment">                                gradient norm.                                */</span>
02201   <span class="keywordtype">double</span> ang_th = 22.5;     <span class="comment">/* Gradient angle tolerance in degrees.           */</span>
02202   <span class="keywordtype">double</span> log_eps = 0.0;     <span class="comment">/* Detection threshold: -log10(NFA) &gt; log_eps     */</span>
02203   <span class="keywordtype">double</span> density_th = 0.7;  <span class="comment">/* Minimal density of region points in rectangle. */</span>
02204   <span class="keywordtype">int</span> n_bins = 1024;        <span class="comment">/* Number of bins in pseudo-ordering of gradient</span>
02205 <span class="comment">                               modulus.                                       */</span>
02206 
02207   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a54">LineSegmentDetection</a>( n_out, img, X, Y, scale, sigma_scale, quant,
02208                                ang_th, log_eps, density_th, n_bins,
02209                                reg_img, reg_x, reg_y );
02210 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a55_cgraph.png" border="0" usemap="#lsd_8c_a55_cgraph_map" alt=""></center>
<map name="lsd_8c_a55_cgraph_map">
<area href="lsd_8c.html#a54" shape="rect" coords="178,337,336,363" alt="">
<area href="lsd_8c.html#a22" shape="rect" coords="620,7,708,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="781,286,832,313" alt="">
<area href="lsd_8c.html#a23" shape="rect" coords="602,109,725,135" alt="">
<area href="lsd_8c.html#a28" shape="rect" coords="596,159,732,186" alt="">
<area href="lsd_8c.html#a32" shape="rect" coords="400,210,530,237" alt="">
<area href="lsd_8c.html#a20" shape="rect" coords="606,261,721,287" alt="">
<area href="lsd_8c.html#a33" shape="rect" coords="630,311,697,338" alt="">
<area href="lsd_8c.html#a25" shape="rect" coords="393,362,537,389" alt="">
<area href="lsd_8c.html#a30" shape="rect" coords="385,413,545,439" alt="">
<area href="lsd_8c.html#a27" shape="rect" coords="398,463,532,490" alt="">
<area href="lsd_8c.html#a51" shape="rect" coords="416,514,514,541" alt="">
<area href="lsd_8c.html#a53" shape="rect" coords="437,615,493,642" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="620,539,708,566" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="617,641,710,667" alt="">
</map>
<a class="anchor" name="a24" doxytag="lsd.c::new_image_char" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00343">343</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00326">image_char_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00368">new_image_char_ini()</a>.
<p>
<div class="fragment"><pre>00344 {
00345   <a class="code" href="structimage__char__s.html">image_char</a> image;
00346 
00347   <span class="comment">/* check parameters */</span>
00348   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char: invalid image size."</span>);
00349 
00350   <span class="comment">/* get memory */</span>
00351   image = (<a class="code" href="structimage__char__s.html">image_char</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__char__s.html">image_char_s</a>) );
00352   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00353   image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc( (size_t) (xsize*ysize),
00354                                           <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) );
00355   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00356 
00357   <span class="comment">/* set image size */</span>
00358   image-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> = xsize;
00359   image-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> = ysize;
00360 
00361   <span class="keywordflow">return</span> image;
00362 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a24_cgraph.png" border="0" usemap="#lsd_8c_a24_cgraph_map" alt=""></center>
<map name="lsd_8c_a24_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="181,8,232,34" alt="">
</map>
<a class="anchor" name="a25" doxytag="lsd.c::new_image_char_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__char__s.html">image_char</a> new_image_char_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_char of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00368">368</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, and <a class="el" href="lsd_8c-source.html#l00343">new_image_char()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00370 {
00371   <a class="code" href="structimage__char__s.html">image_char</a> image = <a class="code" href="lsd_8c.html#a24">new_image_char</a>(xsize,ysize); <span class="comment">/* create image */</span>
00372   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00373   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00374 
00375   <span class="comment">/* check parameters */</span>
00376   <span class="keywordflow">if</span>( image == NULL || image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
00377     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_char_ini: invalid image."</span>);
00378 
00379   <span class="comment">/* initialize */</span>
00380   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[i] = fill_value;
00381 
00382   <span class="keywordflow">return</span> image;
00383 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a25_cgraph.png" border="0" usemap="#lsd_8c_a25_cgraph_map" alt=""></center>
<map name="lsd_8c_a25_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="376,33,426,59" alt="">
<area href="lsd_8c.html#a24" shape="rect" coords="204,58,326,85" alt="">
</map>
<a class="anchor" name="a29" doxytag="lsd.c::new_image_double" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00469">469</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l00732">ll_angle()</a>.
<p>
<div class="fragment"><pre>00470 {
00471   <a class="code" href="structimage__double__s.html">image_double</a> image;
00472 
00473   <span class="comment">/* check parameters */</span>
00474   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double: invalid image size."</span>);
00475 
00476   <span class="comment">/* get memory */</span>
00477   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00478   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00479   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = (<span class="keywordtype">double</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00480   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00481 
00482   <span class="comment">/* set image size */</span>
00483   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00484   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00485 
00486   <span class="keywordflow">return</span> image;
00487 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a29_cgraph.png" border="0" usemap="#lsd_8c_a29_cgraph_map" alt=""></center>
<map name="lsd_8c_a29_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="194,8,245,34" alt="">
</map>
<a class="anchor" name="a30" doxytag="lsd.c::new_image_double_ptr" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__double__s.html">image_double</a> new_image_double_ptr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_double of size 'xsize' times 'ysize' with the data pointed by 'data'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00493">493</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00495 {
00496   <a class="code" href="structimage__double__s.html">image_double</a> image;
00497 
00498   <span class="comment">/* check parameters */</span>
00499   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 )
00500     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: invalid image size."</span>);
00501   <span class="keywordflow">if</span>( data == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_double_ptr: NULL data pointer."</span>);
00502 
00503   <span class="comment">/* get memory */</span>
00504   image = (<a class="code" href="structimage__double__s.html">image_double</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__double__s.html">image_double_s</a>) );
00505   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00506 
00507   <span class="comment">/* set image */</span>
00508   image-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> = xsize;
00509   image-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> = ysize;
00510   image-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> = data;
00511 
00512   <span class="keywordflow">return</span> image;
00513 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a30_cgraph.png" border="0" usemap="#lsd_8c_a30_cgraph_map" alt=""></center>
<map name="lsd_8c_a30_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="218,8,269,34" alt="">
</map>
<a class="anchor" name="a26" doxytag="lsd.c::new_image_int" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00403">403</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00396">image_int_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, <a class="el" href="lsd_8c-source.html#l00397">image_int_s::xsize</a>, and <a class="el" href="lsd_8c-source.html#l00397">image_int_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00427">new_image_int_ini()</a>.
<p>
<div class="fragment"><pre>00404 {
00405   <a class="code" href="structimage__int__s.html">image_int</a> image;
00406 
00407   <span class="comment">/* check parameters */</span>
00408   <span class="keywordflow">if</span>( xsize == 0 || ysize == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_image_int: invalid image size."</span>);
00409 
00410   <span class="comment">/* get memory */</span>
00411   image = (<a class="code" href="structimage__int__s.html">image_int</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structimage__int__s.html">image_int_s</a>) );
00412   <span class="keywordflow">if</span>( image == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00413   image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> = (<span class="keywordtype">int</span> *) calloc( (size_t) (xsize*ysize), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
00414   <span class="keywordflow">if</span>( image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00415 
00416   <span class="comment">/* set image size */</span>
00417   image-&gt;<a class="code" href="structimage__int__s.html#o1">xsize</a> = xsize;
00418   image-&gt;<a class="code" href="structimage__int__s.html#o2">ysize</a> = ysize;
00419 
00420   <span class="keywordflow">return</span> image;
00421 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a26_cgraph.png" border="0" usemap="#lsd_8c_a26_cgraph_map" alt=""></center>
<map name="lsd_8c_a26_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="168,8,218,34" alt="">
</map>
<a class="anchor" name="a27" doxytag="lsd.c::new_image_int_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structimage__int__s.html">image_int</a> new_image_int_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>xsize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ysize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new image_int of size 'xsize' times 'ysize', initialized to the value 'fill_value'. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00427">427</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00396">image_int_s::data</a>, <a class="el" href="lsd_8c.html#a14">image_int</a>, and <a class="el" href="lsd_8c-source.html#l00403">new_image_int()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00429 {
00430   <a class="code" href="structimage__int__s.html">image_int</a> image = <a class="code" href="lsd_8c.html#a26">new_image_int</a>(xsize,ysize); <span class="comment">/* create image */</span>
00431   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = xsize*ysize;
00432   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00433 
00434   <span class="comment">/* initialize */</span>
00435   <span class="keywordflow">for</span>(i=0; i&lt;N; i++) image-&gt;<a class="code" href="structimage__int__s.html#o0">data</a>[i] = fill_value;
00436 
00437   <span class="keywordflow">return</span> image;
00438 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a27_cgraph.png" border="0" usemap="#lsd_8c_a27_cgraph_map" alt=""></center>
<map name="lsd_8c_a27_cgraph_map">
<area href="lsd_8c.html#a26" shape="rect" coords="189,8,301,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="349,8,400,34" alt="">
</map>
<a class="anchor" name="a20" doxytag="lsd.c::new_ntuple_list" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structntuple__list__s.html">ntuple_list</a> new_ntuple_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dim</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an n-tuple list and allocate memory for one element. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dim</em>&nbsp;</td><td>the dimension (n) of the n-tuple. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l00241">241</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00222">ntuple_list_s::dim</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00221">ntuple_list_s::max_size</a>, <a class="el" href="lsd_8c.html#a12">ntuple_list</a>, <a class="el" href="lsd_8c-source.html#l00220">ntuple_list_s::size</a>, and <a class="el" href="lsd_8c-source.html#l00223">ntuple_list_s::values</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l00591">gaussian_sampler()</a>, and <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>00242 {
00243   <a class="code" href="structntuple__list__s.html">ntuple_list</a> n_tuple;
00244 
00245   <span class="comment">/* check parameters */</span>
00246   <span class="keywordflow">if</span>( dim == 0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"new_ntuple_list: 'dim' must be positive."</span>);
00247 
00248   <span class="comment">/* get memory for list structure */</span>
00249   n_tuple = (<a class="code" href="structntuple__list__s.html">ntuple_list</a>) malloc( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structntuple__list__s.html">ntuple_list_s</a>) );
00250   <span class="keywordflow">if</span>( n_tuple == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00251 
00252   <span class="comment">/* initialize list */</span>
00253   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o0">size</a> = 0;
00254   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> = 1;
00255   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o2">dim</a> = dim;
00256 
00257   <span class="comment">/* get memory for tuples */</span>
00258   n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> = (<span class="keywordtype">double</span> *) malloc( dim*n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o1">max_size</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) );
00259   <span class="keywordflow">if</span>( n_tuple-&gt;<a class="code" href="structntuple__list__s.html#o3">values</a> == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"not enough memory."</span>);
00260 
00261   <span class="keywordflow">return</span> n_tuple;
00262 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a20_cgraph.png" border="0" usemap="#lsd_8c_a20_cgraph_map" alt=""></center>
<map name="lsd_8c_a20_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="170,8,221,34" alt="">
</map>
<a class="anchor" name="a39" doxytag="lsd.c::nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes -log10(NFA). 
<p>
NFA stands for Number of False Alarms: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \mathrm{NFA} = NT \cdot B(n,k,p) \]" src="form_7.png">
<p>
<p>
<ul>
<li>NT - number of tests</li><li>B(n,k,p) - tail of binomial distribution with parameters n,k and p: <p class=formulaDsp>
<img class=formulaDsp alt="\[ B(n,k,p) = \sum_{j=k}^n \left(\begin{array}{c}n\\j\end{array}\right) p^{j} (1-p)^{n-j} \]" src="form_8.png">
<p>
</li></ul>
<p>
The value -log10(NFA) is equivalent but more intuitive than NFA:<ul>
<li>-1 corresponds to 10 mean false alarms</li><li>0 corresponds to 1 mean false alarm</li><li>1 corresponds to 0.1 mean false alarms</li><li>2 corresponds to 0.01 mean false alarms</li><li>...</li></ul>
<p>
Used this way, the bigger the value, better the detection, and a logarithmic scale is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>n,k,p</em>&nbsp;</td><td>binomial parameters. </td></tr>
    <tr><td valign=top><em>logNT</em>&nbsp;</td><td>logarithm of Number of Tests</td></tr>
  </table>
</dl>
The computation is based in the gamma function by the following relation: <p class=formulaDsp>
<img class=formulaDsp alt="\[ \left(\begin{array}{c}n\\k\end{array}\right) = \frac{ \Gamma(n+1) }{ \Gamma(k+1) \cdot \Gamma(n-k+1) }. \]" src="form_9.png">
<p>
 We use efficient algorithms to compute the logarithm of the gamma function.<p>
To make the computation faster, not all the sum is computed, part of the terms are neglected based on a bound to the error obtained (an error of 10% in the result is accepted). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01054">1054</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00161">double_equal()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01005">log_gamma</a>, <a class="el" href="lsd_8c-source.html#l00086">M_LN10</a>, and <a class="el" href="lsd_8c-source.html#l01010">TABSIZE</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01055 {
01056   <span class="keyword">static</span> <span class="keywordtype">double</span> inv[<a class="code" href="lsd_8c.html#a11">TABSIZE</a>];   <span class="comment">/* table to keep computed inverse values */</span>
01057   <span class="keywordtype">double</span> tolerance = 0.1;       <span class="comment">/* an error of 10% in the result is accepted */</span>
01058   <span class="keywordtype">double</span> log1term,term,bin_term,mult_term,bin_tail,err,p_term;
01059   <span class="keywordtype">int</span> i;
01060 
01061   <span class="comment">/* check parameters */</span>
01062   <span class="keywordflow">if</span>( n&lt;0 || k&lt;0 || k&gt;n || p&lt;=0.0 || p&gt;=1.0 )
01063     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"nfa: wrong n, k or p values."</span>);
01064 
01065   <span class="comment">/* trivial cases */</span>
01066   <span class="keywordflow">if</span>( n==0 || k==0 ) <span class="keywordflow">return</span> -logNT;
01067   <span class="keywordflow">if</span>( n==k ) <span class="keywordflow">return</span> -logNT - (<span class="keywordtype">double</span>) n * log10(p);
01068 
01069   <span class="comment">/* probability term */</span>
01070   p_term = p / (1.0-p);
01071 
01072   <span class="comment">/* compute the first term of the series */</span>
01073   <span class="comment">/*</span>
01074 <span class="comment">     binomial_tail(n,k,p) = sum_{i=k}^n bincoef(n,i) * p^i * (1-p)^{n-i}</span>
01075 <span class="comment">     where bincoef(n,i) are the binomial coefficients.</span>
01076 <span class="comment">     But</span>
01077 <span class="comment">       bincoef(n,k) = gamma(n+1) / ( gamma(k+1) * gamma(n-k+1) ).</span>
01078 <span class="comment">     We use this to compute the first term. Actually the log of it.</span>
01079 <span class="comment">   */</span>
01080   log1term = <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) n + 1.0 ) - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) k + 1.0 )
01081            - <a class="code" href="lsd_8c.html#a10">log_gamma</a>( (<span class="keywordtype">double</span>) (n-k) + 1.0 )
01082            + (<span class="keywordtype">double</span>) k * log(p) + (<span class="keywordtype">double</span>) (n-k) * log(1.0-p);
01083   term = exp(log1term);
01084 
01085   <span class="comment">/* in some cases no more computations are needed */</span>
01086   <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a17">double_equal</a>(term,0.0) )              <span class="comment">/* the first term is almost zero */</span>
01087     {
01088       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) k &gt; (<span class="keywordtype">double</span>) n * p )     <span class="comment">/* at begin or end of the tail?  */</span>
01089         <span class="keywordflow">return</span> -log1term / <a class="code" href="lsd_8c.html#a0">M_LN10</a> - logNT;  <span class="comment">/* end: use just the first term  */</span>
01090       <span class="keywordflow">else</span>
01091         <span class="keywordflow">return</span> -logNT;                      <span class="comment">/* begin: the tail is roughly 1  */</span>
01092     }
01093 
01094   <span class="comment">/* compute more terms if needed */</span>
01095   bin_tail = term;
01096   <span class="keywordflow">for</span>(i=k+1;i&lt;=n;i++)
01097     {
01098       <span class="comment">/*</span>
01099 <span class="comment">         As</span>
01100 <span class="comment">           term_i = bincoef(n,i) * p^i * (1-p)^(n-i)</span>
01101 <span class="comment">         and</span>
01102 <span class="comment">           bincoef(n,i)/bincoef(n,i-1) = n-1+1 / i,</span>
01103 <span class="comment">         then,</span>
01104 <span class="comment">           term_i / term_i-1 = (n-i+1)/i * p/(1-p)</span>
01105 <span class="comment">         and</span>
01106 <span class="comment">           term_i = term_i-1 * (n-i+1)/i * p/(1-p).</span>
01107 <span class="comment">         1/i is stored in a table as they are computed,</span>
01108 <span class="comment">         because divisions are expensive.</span>
01109 <span class="comment">         p/(1-p) is computed only once and stored in 'p_term'.</span>
01110 <span class="comment">       */</span>
01111       bin_term = (<span class="keywordtype">double</span>) (n-i+1) * ( i&lt;<a class="code" href="lsd_8c.html#a11">TABSIZE</a> ?
01112                    ( inv[i]!=0.0 ? inv[i] : ( inv[i] = 1.0 / (<span class="keywordtype">double</span>) i ) ) :
01113                    1.0 / (<span class="keywordtype">double</span>) i );
01114 
01115       mult_term = bin_term * p_term;
01116       term *= mult_term;
01117       bin_tail += term;
01118       <span class="keywordflow">if</span>(bin_term&lt;1.0)
01119         {
01120           <span class="comment">/* When bin_term&lt;1 then mult_term_j&lt;mult_term_i for j&gt;i.</span>
01121 <span class="comment">             Then, the error on the binomial tail when truncated at</span>
01122 <span class="comment">             the i term can be bounded by a geometric series of form</span>
01123 <span class="comment">             term_i * sum mult_term_i^j.                            */</span>
01124           err = term * ( ( 1.0 - pow( mult_term, (<span class="keywordtype">double</span>) (n-i+1) ) ) /
01125                          (1.0-mult_term) - 1.0 );
01126 
01127           <span class="comment">/* One wants an error at most of tolerance*final_result, or:</span>
01128 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT).</span>
01129 <span class="comment">             Now, the error that can be accepted on bin_tail is</span>
01130 <span class="comment">             given by tolerance*final_result divided by the derivative</span>
01131 <span class="comment">             of -log10(x) when x=bin_tail. that is:</span>
01132 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) / (1/bin_tail)</span>
01133 <span class="comment">             Finally, we truncate the tail if the error is less than:</span>
01134 <span class="comment">             tolerance * abs(-log10(bin_tail)-logNT) * bin_tail        */</span>
01135           <span class="keywordflow">if</span>( err &lt; tolerance * fabs(-log10(bin_tail)-logNT) * bin_tail ) <span class="keywordflow">break</span>;
01136         }
01137     }
01138   <span class="keywordflow">return</span> -log10(bin_tail) - logNT;
01139 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a39_cgraph.png" border="0" usemap="#lsd_8c_a39_cgraph_map" alt=""></center>
<map name="lsd_8c_a39_cgraph_map">
<area href="lsd_8c.html#a17" shape="rect" coords="100,7,201,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="125,58,176,85" alt="">
</map>
<a class="anchor" name="a40" doxytag="lsd.c::rect_copy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void rect_copy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy one rectangle structure to another. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01163">1163</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01155">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01155">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01157">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01156">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01154">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01153">rect::x</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01153">rect::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01736">rect_improve()</a>.
<p>
<div class="fragment"><pre>01164 {
01165   <span class="comment">/* check parameters */</span>
01166   <span class="keywordflow">if</span>( in == NULL || out == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_copy: invalid 'in' or 'out'."</span>);
01167 
01168   <span class="comment">/* copy values */</span>
01169   out-&gt;<a class="code" href="structrect.html#o0">x1</a> = in-&gt;<a class="code" href="structrect.html#o0">x1</a>;
01170   out-&gt;<a class="code" href="structrect.html#o1">y1</a> = in-&gt;<a class="code" href="structrect.html#o1">y1</a>;
01171   out-&gt;<a class="code" href="structrect.html#o2">x2</a> = in-&gt;<a class="code" href="structrect.html#o2">x2</a>;
01172   out-&gt;<a class="code" href="structrect.html#o3">y2</a> = in-&gt;<a class="code" href="structrect.html#o3">y2</a>;
01173   out-&gt;<a class="code" href="structrect.html#o4">width</a> = in-&gt;<a class="code" href="structrect.html#o4">width</a>;
01174   out-&gt;<a class="code" href="structrect.html#o5">x</a> = in-&gt;<a class="code" href="structrect.html#o5">x</a>;
01175   out-&gt;<a class="code" href="structrect.html#o6">y</a> = in-&gt;<a class="code" href="structrect.html#o6">y</a>;
01176   out-&gt;<a class="code" href="structrect.html#o7">theta</a> = in-&gt;<a class="code" href="structrect.html#o7">theta</a>;
01177   out-&gt;<a class="code" href="structrect.html#o8">dx</a> = in-&gt;<a class="code" href="structrect.html#o8">dx</a>;
01178   out-&gt;<a class="code" href="structrect.html#o9">dy</a> = in-&gt;<a class="code" href="structrect.html#o9">dy</a>;
01179   out-&gt;<a class="code" href="structrect.html#o10">prec</a> = in-&gt;<a class="code" href="structrect.html#o10">prec</a>;
01180   out-&gt;<a class="code" href="structrect.html#o11">p</a> = in-&gt;<a class="code" href="structrect.html#o11">p</a>;
01181 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a40_cgraph.png" border="0" usemap="#lsd_8c_a40_cgraph_map" alt=""></center>
<map name="lsd_8c_a40_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="136,8,186,34" alt="">
</map>
<a class="anchor" name="a51" doxytag="lsd.c::rect_improve" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_improve </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>log_eps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try some rectangles variations to improve NFA value. 
<p>
Only if the rectangle is not meaningful (i.e., log_nfa &lt;= log_eps). 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01736">1736</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01155">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01155">rect::dy</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00091">M_PI</a>, <a class="el" href="lsd_8c-source.html#l01157">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01156">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01163">rect_copy()</a>, <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01738 {
01739   <span class="keyword">struct </span><a class="code" href="structrect.html">rect</a> r;
01740   <span class="keywordtype">double</span> log_nfa,log_nfa_new;
01741   <span class="keywordtype">double</span> delta = 0.5;
01742   <span class="keywordtype">double</span> delta_2 = delta / 2.0;
01743   <span class="keywordtype">int</span> n;
01744 
01745   log_nfa = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(rec,angles,logNT);
01746 
01747   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01748 
01749   <span class="comment">/* try finer precisions */</span>
01750   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01751   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01752     {
01753       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01754       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01755       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01756       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01757         {
01758           log_nfa = log_nfa_new;
01759           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01760         }
01761     }
01762 
01763   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01764 
01765   <span class="comment">/* try to reduce width */</span>
01766   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01767   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01768     {
01769       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01770         {
01771           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01772           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01773           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01774             {
01775               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01776               log_nfa = log_nfa_new;
01777             }
01778         }
01779     }
01780 
01781   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01782 
01783   <span class="comment">/* try to reduce one side of the rectangle */</span>
01784   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01785   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01786     {
01787       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01788         {
01789           r.<a class="code" href="structrect.html#o0">x1</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01790           r.<a class="code" href="structrect.html#o1">y1</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01791           r.<a class="code" href="structrect.html#o2">x2</a> += -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01792           r.<a class="code" href="structrect.html#o3">y2</a> +=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01793           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01794           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01795           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01796             {
01797               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01798               log_nfa = log_nfa_new;
01799             }
01800         }
01801     }
01802 
01803   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01804 
01805   <span class="comment">/* try to reduce the other side of the rectangle */</span>
01806   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01807   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01808     {
01809       <span class="keywordflow">if</span>( (r.<a class="code" href="structrect.html#o4">width</a> - delta) &gt;= 0.5 )
01810         {
01811           r.<a class="code" href="structrect.html#o0">x1</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01812           r.<a class="code" href="structrect.html#o1">y1</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01813           r.<a class="code" href="structrect.html#o2">x2</a> -= -r.<a class="code" href="structrect.html#o9">dy</a> * delta_2;
01814           r.<a class="code" href="structrect.html#o3">y2</a> -=  r.<a class="code" href="structrect.html#o8">dx</a> * delta_2;
01815           r.<a class="code" href="structrect.html#o4">width</a> -= delta;
01816           log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01817           <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01818             {
01819               <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01820               log_nfa = log_nfa_new;
01821             }
01822         }
01823     }
01824 
01825   <span class="keywordflow">if</span>( log_nfa &gt; log_eps ) <span class="keywordflow">return</span> log_nfa;
01826 
01827   <span class="comment">/* try even finer precisions */</span>
01828   <a class="code" href="lsd_8c.html#a40">rect_copy</a>(rec,&amp;r);
01829   <span class="keywordflow">for</span>(n=0; n&lt;5; n++)
01830     {
01831       r.<a class="code" href="structrect.html#o11">p</a> /= 2.0;
01832       r.<a class="code" href="structrect.html#o10">prec</a> = r.<a class="code" href="structrect.html#o11">p</a> * <a class="code" href="lsd_8c.html#a1">M_PI</a>;
01833       log_nfa_new = <a class="code" href="lsd_8c.html#a47">rect_nfa</a>(&amp;r,angles,logNT);
01834       <span class="keywordflow">if</span>( log_nfa_new &gt; log_nfa )
01835         {
01836           log_nfa = log_nfa_new;
01837           <a class="code" href="lsd_8c.html#a40">rect_copy</a>(&amp;r,rec);
01838         }
01839     }
01840 
01841   <span class="keywordflow">return</span> log_nfa;
01842 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a51_cgraph.png" border="0" usemap="#lsd_8c_a51_cgraph_map" alt=""></center>
<map name="lsd_8c_a51_cgraph_map">
<area href="lsd_8c.html#a40" shape="rect" coords="381,8,461,34" alt="">
<area href="lsd_8c.html#a47" shape="rect" coords="158,185,228,212" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="661,236,712,262" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="384,109,458,136" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="528,464,568,490" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="278,160,332,186" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="518,261,577,288" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="394,312,448,338" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="280,210,330,237" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="636,413,737,440" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="514,362,581,389" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="510,413,585,440" alt="">
</map>
<a class="anchor" name="a47" doxytag="lsd.c::rect_nfa" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double rect_nfa </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>logNT</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a rectangle's NFA value. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01462">1462</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l01054">nfa()</a>, <a class="el" href="lsd_8c-source.html#l01157">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01156">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01294">ri_del()</a>, <a class="el" href="lsd_8c-source.html#l01305">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01391">ri_ini()</a>, <a class="el" href="lsd_8c-source.html#l01154">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::y</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01736">rect_improve()</a>.
<p>
<div class="fragment"><pre>01463 {
01464   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01465   <span class="keywordtype">int</span> pts = 0;
01466   <span class="keywordtype">int</span> alg = 0;
01467 
01468   <span class="comment">/* check parameters */</span>
01469   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid rectangle."</span>);
01470   <span class="keywordflow">if</span>( angles == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"rect_nfa: invalid 'angles'."</span>);
01471 
01472   <span class="comment">/* compute the total number of pixels and of aligned points in 'rec' */</span>
01473   <span class="keywordflow">for</span>(i=<a class="code" href="lsd_8c.html#a46">ri_ini</a>(rec); !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i); <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i)) <span class="comment">/* rectangle iterator */</span>
01474     <span class="keywordflow">if</span>( i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &gt;= 0 &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &gt;= 0 &amp;&amp;
01475         i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> &amp;&amp; i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> &lt; (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01476       {
01477         ++pts; <span class="comment">/* total number of pixels counter */</span>
01478         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a34">isaligned</a>(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>, i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>, angles, rec-&gt;<a class="code" href="structrect.html#o7">theta</a>, rec-&gt;<a class="code" href="structrect.html#o10">prec</a>) )
01479           ++alg; <span class="comment">/* aligned points counter */</span>
01480       }
01481   <a class="code" href="lsd_8c.html#a43">ri_del</a>(i); <span class="comment">/* delete iterator */</span>
01482 
01483   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a39">nfa</a>(pts,alg,rec-&gt;<a class="code" href="structrect.html#o11">p</a>,logNT); <span class="comment">/* compute NFA value */</span>
01484 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a47_cgraph.png" border="0" usemap="#lsd_8c_a47_cgraph_map" alt=""></center>
<map name="lsd_8c_a47_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="506,210,557,237" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="232,109,306,136" alt="">
<area href="lsd_8c.html#a39" shape="rect" coords="373,312,413,338" alt="">
<area href="lsd_8c.html#a43" shape="rect" coords="129,8,182,34" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="364,160,422,186" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="242,325,296,352" alt="">
<area href="lsd_8c.html#a46" shape="rect" coords="130,286,181,313" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="481,362,582,389" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="360,362,426,389" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="356,413,430,440" alt="">
</map>
<a class="anchor" name="a52" doxytag="lsd.c::reduce_region_radius" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int reduce_region_radius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reduce the region size, by elimination the points far from the starting point, until that leads to rectangle with the right density of region points or to discard the region if too small. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01849">1849</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00187">dist()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00095">FALSE</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00112">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l00099">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00129">point::x</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00129">point::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.
<p>
<div class="fragment"><pre>01854 {
01855   <span class="keywordtype">double</span> density,rad1,rad2,rad,xc,yc;
01856   <span class="keywordtype">int</span> i;
01857 
01858   <span class="comment">/* check parameters */</span>
01859   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg'."</span>);
01860   <span class="keywordflow">if</span>( reg_size == NULL )
01861     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'reg_size'."</span>);
01862   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: 'prec' must be positive."</span>);
01863   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid pointer 'rec'."</span>);
01864   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01865     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'used'."</span>);
01866   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01867     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"reduce_region_radius: invalid image 'angles'."</span>);
01868 
01869   <span class="comment">/* compute region points density */</span>
01870   density = (<span class="keywordtype">double</span>) *reg_size /
01871                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01872 
01873   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01874   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01875 
01876   <span class="comment">/* compute region's radius */</span>
01877   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01878   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01879   rad1 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o0">x1</a>, rec-&gt;<a class="code" href="structrect.html#o1">y1</a> );
01880   rad2 = <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, rec-&gt;<a class="code" href="structrect.html#o2">x2</a>, rec-&gt;<a class="code" href="structrect.html#o3">y2</a> );
01881   rad = rad1 &gt; rad2 ? rad1 : rad2;
01882 
01883   <span class="comment">/* while the density criterion is not satisfied, remove farther pixels */</span>
01884   <span class="keywordflow">while</span>( density &lt; density_th )
01885     {
01886       rad *= 0.75; <span class="comment">/* reduce region's radius to 75% of its value */</span>
01887 
01888       <span class="comment">/* remove points from the region and update 'used' map */</span>
01889       <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01890         <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &gt; rad )
01891           {
01892             <span class="comment">/* point not kept, mark it as NOTUSED */</span>
01893             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01894             <span class="comment">/* remove point from the region */</span>
01895             reg[i].<a class="code" href="structpoint.html#o0">x</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o0">x</a>; <span class="comment">/* if i==*reg_size-1 copy itself */</span>
01896             reg[i].<a class="code" href="structpoint.html#o1">y</a> = reg[*reg_size-1].<a class="code" href="structpoint.html#o1">y</a>;
01897             --(*reg_size);
01898             --i; <span class="comment">/* to avoid skipping one point */</span>
01899           }
01900 
01901       <span class="comment">/* reject if the region is too small.</span>
01902 <span class="comment">         2 is the minimal region size for 'region2rect' to work. */</span>
01903       <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01904 
01905       <span class="comment">/* re-compute rectangle */</span>
01906       <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01907 
01908       <span class="comment">/* re-compute region points density */</span>
01909       density = (<span class="keywordtype">double</span>) *reg_size /
01910                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01911     }
01912 
01913   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01914   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01915 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a52_cgraph.png" border="0" usemap="#lsd_8c_a52_cgraph_map" alt=""></center>
<map name="lsd_8c_a52_cgraph_map">
<area href="lsd_8c.html#a18" shape="rect" coords="232,7,274,34" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="498,109,549,135" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="209,109,297,135" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="346,159,424,186" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="484,159,564,186" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="473,210,574,237" alt="">
</map>
<a class="anchor" name="a53" doxytag="lsd.c::refine" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int refine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>density_th</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refine a rectangle. 
<p>
For that, an estimation of the angle tolerance is performed by the standard deviation of the angle at points near the region's starting point. Then, a new region is grown starting from the same point, but using the estimated angle tolerance. If this fails to produce a rectangle with the right density of region points, 'reduce_region_radius' is called to try to satisfy this condition. 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01927">1927</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00923">angle_diff_signed()</a>, <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00187">dist()</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l00095">FALSE</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00112">NOTUSED</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, <a class="el" href="lsd_8c-source.html#l01591">region2rect()</a>, <a class="el" href="lsd_8c-source.html#l01684">region_grow()</a>, <a class="el" href="lsd_8c-source.html#l00099">TRUE</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l00129">point::x</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00129">point::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>.
<p>
<div class="fragment"><pre>01930 {
01931   <span class="keywordtype">double</span> angle,ang_d,mean_angle,tau,density,xc,yc,ang_c,sum,s_sum;
01932   <span class="keywordtype">int</span> i,n;
01933 
01934   <span class="comment">/* check parameters */</span>
01935   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg'."</span>);
01936   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'reg_size'."</span>);
01937   <span class="keywordflow">if</span>( prec &lt; 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: 'prec' must be positive."</span>);
01938   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid pointer 'rec'."</span>);
01939   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01940     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'used'."</span>);
01941   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01942     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"refine: invalid image 'angles'."</span>);
01943 
01944   <span class="comment">/* compute region points density */</span>
01945   density = (<span class="keywordtype">double</span>) *reg_size /
01946                          ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01947 
01948   <span class="comment">/* if the density criterion is satisfied there is nothing to do */</span>
01949   <span class="keywordflow">if</span>( density &gt;= density_th ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01950 
01951   <span class="comment">/*------ First try: reduce angle tolerance ------*/</span>
01952 
01953   <span class="comment">/* compute the new mean angle and tolerance */</span>
01954   xc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o0">x</a>;
01955   yc = (<span class="keywordtype">double</span>) reg[0].<a class="code" href="structpoint.html#o1">y</a>;
01956   ang_c = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[0].<a class="code" href="structpoint.html#o0">x</a> + reg[0].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01957   sum = s_sum = 0.0;
01958   n = 0;
01959   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01960     {
01961       used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> ] = <a class="code" href="lsd_8c.html#a7">NOTUSED</a>;
01962       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a18">dist</a>( xc, yc, (<span class="keywordtype">double</span>) reg[i].x, (<span class="keywordtype">double</span>) reg[i].y ) &lt; rec-&gt;<a class="code" href="structrect.html#o4">width</a> )
01963         {
01964           angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01965           ang_d = <a class="code" href="lsd_8c.html#a36">angle_diff_signed</a>(angle,ang_c);
01966           sum += ang_d;
01967           s_sum += ang_d * ang_d;
01968           ++n;
01969         }
01970     }
01971   mean_angle = sum / (<span class="keywordtype">double</span>) n;
01972   tau = 2.0 * sqrt( (s_sum - 2.0 * mean_angle * sum) / (<span class="keywordtype">double</span>) n
01973                          + mean_angle*mean_angle ); <span class="comment">/* 2 * standard deviation */</span>
01974 
01975   <span class="comment">/* find a new region from the same starting point and new angle tolerance */</span>
01976   <a class="code" href="lsd_8c.html#a50">region_grow</a>(reg[0].x,reg[0].y,angles,reg,reg_size,&amp;reg_angle,used,tau);
01977 
01978   <span class="comment">/* if the region is too small, reject */</span>
01979   <span class="keywordflow">if</span>( *reg_size &lt; 2 ) <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a2">FALSE</a>;
01980 
01981   <span class="comment">/* re-compute rectangle */</span>
01982   <a class="code" href="lsd_8c.html#a49">region2rect</a>(reg,*reg_size,modgrad,reg_angle,prec,p,rec);
01983 
01984   <span class="comment">/* re-compute region points density */</span>
01985   density = (<span class="keywordtype">double</span>) *reg_size /
01986                       ( <a class="code" href="lsd_8c.html#a18">dist</a>(rec-&gt;<a class="code" href="structrect.html#o0">x1</a>,rec-&gt;<a class="code" href="structrect.html#o1">y1</a>,rec-&gt;<a class="code" href="structrect.html#o2">x2</a>,rec-&gt;<a class="code" href="structrect.html#o3">y2</a>) * rec-&gt;<a class="code" href="structrect.html#o4">width</a> );
01987 
01988   <span class="comment">/*------ Second try: reduce region radius ------*/</span>
01989   <span class="keywordflow">if</span>( density &lt; density_th )
01990     <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a52">reduce_region_radius</a>( reg, reg_size, modgrad, reg_angle, prec, p,
01991                                  rec, used, angles, density_th );
01992 
01993   <span class="comment">/* if this point is reached, the density criterion is satisfied */</span>
01994   <span class="keywordflow">return</span> <a class="code" href="lsd_8c.html#a3">TRUE</a>;
01995 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a53_cgraph.png" border="0" usemap="#lsd_8c_a53_cgraph_map" alt=""></center>
<map name="lsd_8c_a53_cgraph_map">
<area href="lsd_8c.html#a36" shape="rect" coords="125,8,250,34" alt="">
<area href="lsd_8c.html#a18" shape="rect" coords="338,160,381,186" alt="">
<area href="lsd_8c.html#a16" shape="rect" coords="607,210,658,237" alt="">
<area href="lsd_8c.html#a52" shape="rect" coords="113,210,262,237" alt="">
<area href="lsd_8c.html#a49" shape="rect" coords="315,261,403,288" alt="">
<area href="lsd_8c.html#a50" shape="rect" coords="313,109,406,136" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="455,312,533,338" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="593,337,673,364" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="582,286,683,313" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="457,160,531,186" alt="">
</map>
<a class="anchor" name="a49" doxytag="lsd.c::region2rect" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region2rect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>modgrad</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes a rectangle that covers a region of points. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01591">1591</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l01155">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01155">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01548">get_theta()</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l01157">rect::p</a>, <a class="el" href="lsd_8c-source.html#l01156">rect::prec</a>, <a class="el" href="lsd_8c-source.html#l01154">rect::theta</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01153">rect::x</a>, <a class="el" href="lsd_8c-source.html#l00129">point::x</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l01153">rect::y</a>, <a class="el" href="lsd_8c-source.html#l00129">point::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, and <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, <a class="el" href="lsd_8c-source.html#l01849">reduce_region_radius()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.
<p>
<div class="fragment"><pre>01594 {
01595   <span class="keywordtype">double</span> x,y,dx,dy,l,w,theta,weight,sum,l_min,l_max,w_min,w_max;
01596   <span class="keywordtype">int</span> i;
01597 
01598   <span class="comment">/* check parameters */</span>
01599   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid region."</span>);
01600   <span class="keywordflow">if</span>( reg_size &lt;= 1 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: region size &lt;= 1."</span>);
01601   <span class="keywordflow">if</span>( modgrad == NULL || modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01602     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid image 'modgrad'."</span>);
01603   <span class="keywordflow">if</span>( rec == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: invalid 'rec'."</span>);
01604 
01605   <span class="comment">/* center of the region:</span>
01606 <span class="comment"></span>
01607 <span class="comment">     It is computed as the weighted sum of the coordinates</span>
01608 <span class="comment">     of all the pixels in the region. The norm of the gradient</span>
01609 <span class="comment">     is used as the weight of a pixel. The sum is as follows:</span>
01610 <span class="comment">       cx = \sum_i G(i).x_i</span>
01611 <span class="comment">       cy = \sum_i G(i).y_i</span>
01612 <span class="comment">     where G(i) is the norm of the gradient of pixel i</span>
01613 <span class="comment">     and x_i,y_i are its coordinates.</span>
01614 <span class="comment">   */</span>
01615   x = y = sum = 0.0;
01616   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01617     {
01618       weight = modgrad-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[ reg[i].<a class="code" href="structpoint.html#o0">x</a> + reg[i].<a class="code" href="structpoint.html#o1">y</a> * modgrad-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> ];
01619       x += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> * weight;
01620       y += (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> * weight;
01621       sum += weight;
01622     }
01623   <span class="keywordflow">if</span>( sum &lt;= 0.0 ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region2rect: weights sum equal to zero."</span>);
01624   x /= sum;
01625   y /= sum;
01626 
01627   <span class="comment">/* theta */</span>
01628   theta = <a class="code" href="lsd_8c.html#a48">get_theta</a>(reg,reg_size,x,y,modgrad,reg_angle,prec);
01629 
01630   <span class="comment">/* length and width:</span>
01631 <span class="comment"></span>
01632 <span class="comment">     'l' and 'w' are computed as the distance from the center of the</span>
01633 <span class="comment">     region to pixel i, projected along the rectangle axis (dx,dy) and</span>
01634 <span class="comment">     to the orthogonal axis (-dy,dx), respectively.</span>
01635 <span class="comment"></span>
01636 <span class="comment">     The length of the rectangle goes from l_min to l_max, where l_min</span>
01637 <span class="comment">     and l_max are the minimum and maximum values of l in the region.</span>
01638 <span class="comment">     Analogously, the width is selected from w_min to w_max, where</span>
01639 <span class="comment">     w_min and w_max are the minimum and maximum of w for the pixels</span>
01640 <span class="comment">     in the region.</span>
01641 <span class="comment">   */</span>
01642   dx = cos(theta);
01643   dy = sin(theta);
01644   l_min = l_max = w_min = w_max = 0.0;
01645   <span class="keywordflow">for</span>(i=0; i&lt;reg_size; i++)
01646     {
01647       l =  ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dx + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dy;
01648       w = -( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o0">x</a> - x) * dy + ( (<span class="keywordtype">double</span>) reg[i].<a class="code" href="structpoint.html#o1">y</a> - y) * dx;
01649 
01650       <span class="keywordflow">if</span>( l &gt; l_max ) l_max = l;
01651       <span class="keywordflow">if</span>( l &lt; l_min ) l_min = l;
01652       <span class="keywordflow">if</span>( w &gt; w_max ) w_max = w;
01653       <span class="keywordflow">if</span>( w &lt; w_min ) w_min = w;
01654     }
01655 
01656   <span class="comment">/* store values */</span>
01657   rec-&gt;<a class="code" href="structrect.html#o0">x1</a> = x + l_min * dx;
01658   rec-&gt;<a class="code" href="structrect.html#o1">y1</a> = y + l_min * dy;
01659   rec-&gt;<a class="code" href="structrect.html#o2">x2</a> = x + l_max * dx;
01660   rec-&gt;<a class="code" href="structrect.html#o3">y2</a> = y + l_max * dy;
01661   rec-&gt;<a class="code" href="structrect.html#o4">width</a> = w_max - w_min;
01662   rec-&gt;<a class="code" href="structrect.html#o5">x</a> = x;
01663   rec-&gt;<a class="code" href="structrect.html#o6">y</a> = y;
01664   rec-&gt;<a class="code" href="structrect.html#o7">theta</a> = theta;
01665   rec-&gt;<a class="code" href="structrect.html#o8">dx</a> = dx;
01666   rec-&gt;<a class="code" href="structrect.html#o9">dy</a> = dy;
01667   rec-&gt;<a class="code" href="structrect.html#o10">prec</a> = prec;
01668   rec-&gt;<a class="code" href="structrect.html#o11">p</a> = p;
01669 
01670   <span class="comment">/* we impose a minimal width of one pixel</span>
01671 <span class="comment"></span>
01672 <span class="comment">     A sharp horizontal or vertical step would produce a perfectly</span>
01673 <span class="comment">     horizontal or vertical region. The width computed would be</span>
01674 <span class="comment">     zero. But that corresponds to a one pixels width transition in</span>
01675 <span class="comment">     the image.</span>
01676 <span class="comment">   */</span>
01677   <span class="keywordflow">if</span>( rec-&gt;<a class="code" href="structrect.html#o4">width</a> &lt; 1.0 ) rec-&gt;<a class="code" href="structrect.html#o4">width</a> = 1.0;
01678 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a49_cgraph.png" border="0" usemap="#lsd_8c_a49_cgraph_map" alt=""></center>
<map name="lsd_8c_a49_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="298,8,349,34" alt="">
<area href="lsd_8c.html#a48" shape="rect" coords="146,58,224,85" alt="">
<area href="lsd_8c.html#a35" shape="rect" coords="284,58,364,85" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="273,109,374,136" alt="">
</map>
<a class="anchor" name="a50" doxytag="lsd.c::region_grow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void region_grow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__double__s.html">image_double</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpoint.html">point</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>reg_angle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structimage__char__s.html">image_char</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>used</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>prec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build a region of pixels that share the same angle, up to a tolerance 'prec', starting at point (x,y). 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01684">1684</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00325">image_char_s::data</a>, <a class="el" href="lsd_8c-source.html#l00451">image_double_s::data</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c.html#a13">image_char</a>, <a class="el" href="lsd_8c.html#a15">image_double</a>, <a class="el" href="lsd_8c-source.html#l00873">isaligned()</a>, <a class="el" href="lsd_8c-source.html#l00115">USED</a>, <a class="el" href="lsd_8c-source.html#l00129">point::x</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00452">image_double_s::xsize</a>, <a class="el" href="lsd_8c-source.html#l00129">point::y</a>, <a class="el" href="lsd_8c-source.html#l00326">image_char_s::ysize</a>, and <a class="el" href="lsd_8c-source.html#l00452">image_double_s::ysize</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l02005">LineSegmentDetection()</a>, and <a class="el" href="lsd_8c-source.html#l01927">refine()</a>.
<p>
<div class="fragment"><pre>01687 {
01688   <span class="keywordtype">double</span> sumdx,sumdy;
01689   <span class="keywordtype">int</span> xx,yy,i;
01690 
01691   <span class="comment">/* check parameters */</span>
01692   <span class="keywordflow">if</span>( x &lt; 0 || y &lt; 0 || x &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a> || y &gt;= (<span class="keywordtype">int</span>) angles-&gt;<a class="code" href="structimage__double__s.html#o2">ysize</a> )
01693     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: (x,y) out of the image."</span>);
01694   <span class="keywordflow">if</span>( angles == NULL || angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a> == NULL )
01695     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'angles'."</span>);
01696   <span class="keywordflow">if</span>( reg == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid 'reg'."</span>);
01697   <span class="keywordflow">if</span>( reg_size == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_size'."</span>);
01698   <span class="keywordflow">if</span>( reg_angle == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid pointer 'reg_angle'."</span>);
01699   <span class="keywordflow">if</span>( used == NULL || used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a> == NULL )
01700     <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"region_grow: invalid image 'used'."</span>);
01701 
01702   <span class="comment">/* first point of the region */</span>
01703   *reg_size = 1;
01704   reg[0].<a class="code" href="structpoint.html#o0">x</a> = x;
01705   reg[0].<a class="code" href="structpoint.html#o1">y</a> = y;
01706   *reg_angle = angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[x+y*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>];  <span class="comment">/* region's angle */</span>
01707   sumdx = cos(*reg_angle);
01708   sumdy = sin(*reg_angle);
01709   used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[x+y*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01710 
01711   <span class="comment">/* try neighbors as new region points */</span>
01712   <span class="keywordflow">for</span>(i=0; i&lt;*reg_size; i++)
01713     <span class="keywordflow">for</span>(xx=reg[i].<a class="code" href="structpoint.html#o0">x</a>-1; xx&lt;=reg[i].x+1; xx++)
01714       <span class="keywordflow">for</span>(yy=reg[i].y-1; yy&lt;=reg[i].y+1; yy++)
01715         <span class="keywordflow">if</span>( xx&gt;=0 &amp;&amp; yy&gt;=0 &amp;&amp; xx&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a> &amp;&amp; yy&lt;(<span class="keywordtype">int</span>)used-&gt;<a class="code" href="structimage__char__s.html#o2">ysize</a> &amp;&amp;
01716             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] != <a class="code" href="lsd_8c.html#a8">USED</a> &amp;&amp;
01717             <a class="code" href="lsd_8c.html#a34">isaligned</a>(xx,yy,angles,*reg_angle,prec) )
01718           {
01719             <span class="comment">/* add point */</span>
01720             used-&gt;<a class="code" href="structimage__char__s.html#o0">data</a>[xx+yy*used-&gt;<a class="code" href="structimage__char__s.html#o1">xsize</a>] = <a class="code" href="lsd_8c.html#a8">USED</a>;
01721             reg[*reg_size].x = xx;
01722             reg[*reg_size].y = yy;
01723             ++(*reg_size);
01724 
01725             <span class="comment">/* update region's angle */</span>
01726             sumdx += cos( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01727             sumdy += sin( angles-&gt;<a class="code" href="structimage__double__s.html#o0">data</a>[xx+yy*angles-&gt;<a class="code" href="structimage__double__s.html#o1">xsize</a>] );
01728             *reg_angle = atan2(sumdy,sumdx);
01729           }
01730 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a50_cgraph.png" border="0" usemap="#lsd_8c_a50_cgraph_map" alt=""></center>
<map name="lsd_8c_a50_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="274,33,325,59" alt="">
<area href="lsd_8c.html#a34" shape="rect" coords="151,58,226,85" alt="">
</map>
<a class="anchor" name="a43" doxytag="lsd.c::ri_del" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_del </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory used by a rectangle iterator. 
<p>

<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01294">1294</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00139">error()</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01295 {
01296   <span class="keywordflow">if</span>( iter == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_del: NULL iterator."</span>);
01297   free( (<span class="keywordtype">void</span> *) iter );
01298 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a43_cgraph.png" border="0" usemap="#lsd_8c_a43_cgraph_map" alt=""></center>
<map name="lsd_8c_a43_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="112,8,162,34" alt="">
</map>
<a class="anchor" name="a44" doxytag="lsd.c::ri_end" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ri_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the iterator finished the full iteration. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01305">1305</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01241">rect_iter::vx</a>, and <a class="el" href="lsd_8c-source.html#l01244">rect_iter::x</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>.
<p>
<div class="fragment"><pre>01306 {
01307   <span class="comment">/* check input */</span>
01308   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_end: NULL iterator."</span>);
01309 
01310   <span class="comment">/* if the current x value is larger than the largest</span>
01311 <span class="comment">     x value in the rectangle (vx[2]), we know the full</span>
01312 <span class="comment">     exploration of the rectangle is finished. */</span>
01313   <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)(i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2];
01314 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a44_cgraph.png" border="0" usemap="#lsd_8c_a44_cgraph_map" alt=""></center>
<map name="lsd_8c_a44_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="114,8,165,34" alt="">
</map>
<a class="anchor" name="a45" doxytag="lsd.c::ri_inc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ri_inc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structrect__iter.html">rect_iter</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01321">1321</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01279">inter_hi()</a>, <a class="el" href="lsd_8c-source.html#l01257">inter_low()</a>, <a class="el" href="lsd_8c-source.html#l01305">ri_end()</a>, <a class="el" href="lsd_8c-source.html#l01241">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01242">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01243">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01243">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>, and <a class="el" href="lsd_8c-source.html#l01391">ri_ini()</a>.
<p>
<div class="fragment"><pre>01322 {
01323   <span class="comment">/* check input */</span>
01324   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_inc: NULL iterator."</span>);
01325 
01326   <span class="comment">/* if not at end of exploration,</span>
01327 <span class="comment">     increase y value for next pixel in the 'column' */</span>
01328   <span class="keywordflow">if</span>( !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>++;
01329 
01330   <span class="comment">/* if the end of the current 'column' is reached,</span>
01331 <span class="comment">     and it is not the end of exploration,</span>
01332 <span class="comment">     advance to the next 'column' */</span>
01333   <span class="keywordflow">while</span>( (<span class="keywordtype">double</span>) (i-&gt;<a class="code" href="structrect__iter.html#o5">y</a>) &gt; i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> &amp;&amp; !<a class="code" href="lsd_8c.html#a44">ri_end</a>(i) )
01334     {
01335       <span class="comment">/* increase x, next 'column' */</span>
01336       i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>++;
01337 
01338       <span class="comment">/* if end of exploration, return */</span>
01339       <span class="keywordflow">if</span>( <a class="code" href="lsd_8c.html#a44">ri_end</a>(i) ) <span class="keywordflow">return</span>;
01340 
01341       <span class="comment">/* update lower y limit (start) for the new 'column'.</span>
01342 <span class="comment"></span>
01343 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01344 <span class="comment">         lower side of the rectangle. The first thing is to decide if</span>
01345 <span class="comment">         the corresponding side is</span>
01346 <span class="comment"></span>
01347 <span class="comment">           vx[0],vy[0] to vx[3],vy[3] or</span>
01348 <span class="comment">           vx[3],vy[3] to vx[2],vy[2]</span>
01349 <span class="comment"></span>
01350 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01351 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01352 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01353 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01354 <span class="comment">         by using 'inter_low'.</span>
01355 <span class="comment">       */</span>
01356       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>) i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3] )
01357         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3]);
01358       <span class="keywordflow">else</span>
01359         i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = <a class="code" href="lsd_8c.html#a41">inter_low</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[3],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01360 
01361       <span class="comment">/* update upper y limit (end) for the new 'column'.</span>
01362 <span class="comment"></span>
01363 <span class="comment">         We need to interpolate the y value that corresponds to the</span>
01364 <span class="comment">         upper side of the rectangle. The first thing is to decide if</span>
01365 <span class="comment">         the corresponding side is</span>
01366 <span class="comment"></span>
01367 <span class="comment">           vx[0],vy[0] to vx[1],vy[1] or</span>
01368 <span class="comment">           vx[1],vy[1] to vx[2],vy[2]</span>
01369 <span class="comment"></span>
01370 <span class="comment">         Then, the side is interpolated for the x value of the</span>
01371 <span class="comment">         'column'. But, if the side is vertical (as it could happen if</span>
01372 <span class="comment">         the rectangle is vertical and we are dealing with the first</span>
01373 <span class="comment">         or last 'columns') then we pick the lower value of the side</span>
01374 <span class="comment">         by using 'inter_low'.</span>
01375 <span class="comment">       */</span>
01376       <span class="keywordflow">if</span>( (<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> &lt; i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1] )
01377         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1]);
01378       <span class="keywordflow">else</span>
01379         i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = <a class="code" href="lsd_8c.html#a42">inter_hi</a>((<span class="keywordtype">double</span>)i-&gt;<a class="code" href="structrect__iter.html#o4">x</a>,i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[1],i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[2],i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[2]);
01380 
01381       <span class="comment">/* new y */</span>
01382       i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a>);
01383     }
01384 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a45_cgraph.png" border="0" usemap="#lsd_8c_a45_cgraph_map" alt=""></center>
<map name="lsd_8c_a45_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="263,72,314,98" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="117,109,183,136" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="113,160,187,186" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="121,58,179,85" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="238,148,339,174" alt="">
</map>
<a class="anchor" name="a46" doxytag="lsd.c::ri_ini" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structrect__iter.html">rect_iter</a>* ri_ini </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structrect.html">rect</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create and initialize a rectangle iterator. 
<p>
See details in <a class="el" href="structrect__iter.html">rect_iter</a> 
<p>
Definition at line <a class="el" href="lsd_8c-source.html#l01391">1391</a> of file <a class="el" href="lsd_8c-source.html">lsd.c</a>.
<p>
References <a class="el" href="lsd_8c-source.html#l01155">rect::dx</a>, <a class="el" href="lsd_8c-source.html#l01155">rect::dy</a>, <a class="el" href="lsd_8c-source.html#l00139">error()</a>, <a class="el" href="lsd_8c-source.html#l01321">ri_inc()</a>, <a class="el" href="lsd_8c-source.html#l01241">rect_iter::vx</a>, <a class="el" href="lsd_8c-source.html#l01242">rect_iter::vy</a>, <a class="el" href="lsd_8c-source.html#l01152">rect::width</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::x</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::x2</a>, <a class="el" href="lsd_8c-source.html#l01244">rect_iter::y</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y1</a>, <a class="el" href="lsd_8c-source.html#l01151">rect::y2</a>, <a class="el" href="lsd_8c-source.html#l01243">rect_iter::ye</a>, and <a class="el" href="lsd_8c-source.html#l01243">rect_iter::ys</a>.
<p>
Referenced by <a class="el" href="lsd_8c-source.html#l01462">rect_nfa()</a>.
<p>
<div class="fragment"><pre>01392 {
01393   <span class="keywordtype">double</span> vx[4],vy[4];
01394   <span class="keywordtype">int</span> n,offset;
01395   <a class="code" href="structrect__iter.html">rect_iter</a> * i;
01396 
01397   <span class="comment">/* check parameters */</span>
01398   <span class="keywordflow">if</span>( r == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: invalid rectangle."</span>);
01399 
01400   <span class="comment">/* get memory */</span>
01401   i = (<a class="code" href="structrect__iter.html">rect_iter</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structrect__iter.html">rect_iter</a>));
01402   <span class="keywordflow">if</span>( i == NULL ) <a class="code" href="lsd_8c.html#a16">error</a>(<span class="stringliteral">"ri_ini: Not enough memory."</span>);
01403 
01404   <span class="comment">/* build list of rectangle corners ordered</span>
01405 <span class="comment">     in a circular way around the rectangle */</span>
01406   vx[0] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01407   vy[0] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01408   vx[1] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> - r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01409   vy[1] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> + r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01410   vx[2] = r-&gt;<a class="code" href="structrect.html#o2">x2</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01411   vy[2] = r-&gt;<a class="code" href="structrect.html#o3">y2</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01412   vx[3] = r-&gt;<a class="code" href="structrect.html#o0">x1</a> + r-&gt;<a class="code" href="structrect.html#o9">dy</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01413   vy[3] = r-&gt;<a class="code" href="structrect.html#o1">y1</a> - r-&gt;<a class="code" href="structrect.html#o8">dx</a> * r-&gt;<a class="code" href="structrect.html#o4">width</a> / 2.0;
01414 
01415   <span class="comment">/* compute rotation of index of corners needed so that the first</span>
01416 <span class="comment">     point has the smaller x.</span>
01417 <span class="comment"></span>
01418 <span class="comment">     if one side is vertical, thus two corners have the same smaller x</span>
01419 <span class="comment">     value, the one with the largest y value is selected as the first.</span>
01420 <span class="comment">   */</span>
01421   <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &lt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 0;
01422   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &lt; r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 1;
01423   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( r-&gt;<a class="code" href="structrect.html#o0">x1</a> &gt; r-&gt;<a class="code" href="structrect.html#o2">x2</a> &amp;&amp; r-&gt;<a class="code" href="structrect.html#o1">y1</a> &gt;= r-&gt;<a class="code" href="structrect.html#o3">y2</a> ) offset = 2;
01424   <span class="keywordflow">else</span> offset = 3;
01425 
01426   <span class="comment">/* apply rotation of index. */</span>
01427   <span class="keywordflow">for</span>(n=0; n&lt;4; n++)
01428     {
01429       i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[n] = vx[(offset+n)%4];
01430       i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[n] = vy[(offset+n)%4];
01431     }
01432 
01433   <span class="comment">/* Set an initial condition.</span>
01434 <span class="comment"></span>
01435 <span class="comment">     The values are set to values that will cause 'ri_inc' (that will</span>
01436 <span class="comment">     be called immediately) to initialize correctly the first 'column'</span>
01437 <span class="comment">     and compute the limits 'ys' and 'ye'.</span>
01438 <span class="comment"></span>
01439 <span class="comment">     'y' is set to the integer value of vy[0], the starting corner.</span>
01440 <span class="comment"></span>
01441 <span class="comment">     'ys' and 'ye' are set to very small values, so 'ri_inc' will</span>
01442 <span class="comment">     notice that it needs to start a new 'column'.</span>
01443 <span class="comment"></span>
01444 <span class="comment">     The smallest integer coordinate inside of the rectangle is</span>
01445 <span class="comment">     'ceil(vx[0])'. The current 'x' value is set to that value minus</span>
01446 <span class="comment">     one, so 'ri_inc' (that will increase x by one) will advance to</span>
01447 <span class="comment">     the first 'column'.</span>
01448 <span class="comment">   */</span>
01449   i-&gt;<a class="code" href="structrect__iter.html#o4">x</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o0">vx</a>[0]) - 1;
01450   i-&gt;<a class="code" href="structrect__iter.html#o5">y</a> = (<span class="keywordtype">int</span>) ceil(i-&gt;<a class="code" href="structrect__iter.html#o1">vy</a>[0]);
01451   i-&gt;<a class="code" href="structrect__iter.html#o2">ys</a> = i-&gt;<a class="code" href="structrect__iter.html#o3">ye</a> = -DBL_MAX;
01452 
01453   <span class="comment">/* advance to the first pixel */</span>
01454   <a class="code" href="lsd_8c.html#a45">ri_inc</a>(i);
01455 
01456   <span class="keywordflow">return</span> i;
01457 }
</pre></div>    </td>
  </tr>
</table>

<p>
Here is the call graph for this function:<p><center><img src="lsd_8c_a46_cgraph.png" border="0" usemap="#lsd_8c_a46_cgraph_map" alt=""></center>
<map name="lsd_8c_a46_cgraph_map">
<area href="lsd_8c.html#a16" shape="rect" coords="362,109,413,135" alt="">
<area href="lsd_8c.html#a45" shape="rect" coords="108,109,161,135" alt="">
<area href="lsd_8c.html#a42" shape="rect" coords="216,159,282,186" alt="">
<area href="lsd_8c.html#a41" shape="rect" coords="212,210,286,237" alt="">
<area href="lsd_8c.html#a44" shape="rect" coords="220,109,278,135" alt="">
<area href="lsd_8c.html#a17" shape="rect" coords="337,185,438,211" alt="">
</map>
<hr size="1"><address style="align: right;"><small>Generated on Fri Nov 11 11:11:34 2011 for LSD by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
